// This file is generated by DaggerSDK.SourceGenerator
#nullable enable
using System.Text.Json.Serialization;
using Dagger;

/// <summary>
/// The `Boolean` scalar type represents `true` or `false`.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<Boolean>))]
public class Boolean : Scalar
{
}

/// <summary>
/// Key value object that represents a build argument.
/// </summary>
public struct BuildArg(string? name = null, string? value = null) : IInputObject
{
    public Dictionary<string, IFormattedValue> ToDictionary() => this.AsDictionary();
    /// <summary>
    /// The build argument name.
    /// </summary>
    public string? Name { get; } = name;
    /// <summary>
    /// The build argument value.
    /// </summary>
    public string? Value { get; } = value;
}

/// <summary>
/// Sharing mode of the cache volume.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter<CacheSharingMode>))]
public enum CacheSharingMode
{
    /// <summary>
    /// Shares the cache volume amongst many build pipelines
    /// </summary>
    SHARED,
    /// <summary>
    /// Keeps a cache volume for a single build pipeline
    /// </summary>
    PRIVATE,
    /// <summary>
    /// Shares the cache volume amongst many build pipelines, but will serialize the writes
    /// </summary>
    LOCKED
}

/// <summary>
/// A directory whose contents persist across runs.
/// </summary>
public partial class CacheVolume(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<CacheVolumeID>
{
    /// <summary>
    /// A unique identifier for this CacheVolume.
    /// </summary>
    public async Task<CacheVolumeID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<CacheVolumeID>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `CacheVolumeID` scalar type represents an identifier for an object of type CacheVolume.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<CacheVolumeID>))]
public class CacheVolumeID : Scalar
{
}

/// <summary>
/// An OCI-compatible container, also known as a Docker container.
/// </summary>
public partial class Container(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<ContainerID>
{
    /// <summary>
    /// Turn the container into a Service.
    /// Be sure to set any exposed ports before this conversion.
    /// </summary>
    /// <param name="args">
    /// Command to run instead of the container's default command (e.g., ["go", "run", "main.go"]).
    /// If empty, the container's default command is used.
    /// </param>
    /// <param name="useEntrypoint">
    /// If the container has an entrypoint, prepend it to the args.
    /// </param>
    /// <param name="experimentalPrivilegedNesting">
    /// Provides Dagger access to the executed command.
    /// Do not use this option unless you trust the command being executed; the command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
    /// </param>
    /// <param name="insecureRootCapabilities">
    /// Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the args according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    /// <param name="noInit">
    /// If set, skip the automatic init process injected into containers by default.
    /// This should only be used if the user requires that their exec process be the pid 1 process in the container. Otherwise it may result in unexpected behavior.
    /// </param>
    public Service AsService(string[]? args = null, bool? useEntrypoint = false, bool? experimentalPrivilegedNesting = false, bool? insecureRootCapabilities = false, bool? expand = false, bool? noInit = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(args, useEntrypoint, experimentalPrivilegedNesting, insecureRootCapabilities, expand, noInit);
        var queryBuilder = QueryBuilder.Select("asService", arguments);
        return new Service(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns a File representing the container serialized to a tarball.
    /// </summary>
    /// <param name="platformVariants">
    /// Identifiers for other platform specific containers.
    /// Used for multi-platform images.
    /// </param>
    /// <param name="forcedCompression">
    /// Force each layer of the image to use the specified compression algorithm.
    /// If this is unset, then if a layer already has a compressed blob in the engine's cache, that will be used (this can result in a mix of compression algorithms for different layers). If this is unset and a layer has no compressed blob in the engine's cache, then it will be compressed using Gzip.
    /// </param>
    /// <param name="mediaTypes">
    /// Use the specified media types for the image's layers.
    /// Defaults to OCI, which is largely compatible with most recent container runtimes, but Docker may be needed for older runtimes without OCI support.
    /// </param>
    public File AsTarball(Container[]? platformVariants = null, ImageLayerCompression? forcedCompression = null, ImageMediaTypes? mediaTypes = ImageMediaTypes.OCIMediaTypes)
    {
        var arguments = ArgumentsBuilder.GetArguments(platformVariants, forcedCompression, mediaTypes);
        var queryBuilder = QueryBuilder.Select("asTarball", arguments);
        return new File(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Initializes this container from a Dockerfile build.
    /// </summary>
    /// <param name="context">
    /// Directory context used by the Dockerfile.
    /// </param>
    /// <param name="dockerfile">
    /// Path to the Dockerfile to use.
    /// </param>
    /// <param name="target">
    /// Target build stage to build.
    /// </param>
    /// <param name="buildArgs">
    /// Additional build arguments.
    /// </param>
    /// <param name="secrets">
    /// Secrets to pass to the build.
    /// They will be mounted at /run/secrets/[secret-name] in the build container
    /// They can be accessed in the Dockerfile using the "secret" mount type and mount path /run/secrets/[secret-name], e.g. RUN --mount=type=secret,id=my-secret curl [http://example.com?token=$(cat /run/secrets/my-secret)](http://example.com?token=$(cat /run/secrets/my-secret))
    /// </param>
    public Container Build(Directory context, string? dockerfile = "Dockerfile", string? target = "", BuildArg[]? buildArgs = null, Secret[]? secrets = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(context, dockerfile, target, buildArgs, secrets);
        var queryBuilder = QueryBuilder.Select("build", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves default arguments for future commands.
    /// </summary>
    public async Task<string> DefaultArgsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("defaultArgs", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves a directory at the given path.
    /// Mounts are included.
    /// </summary>
    /// <param name="path">
    /// The path of the directory to retrieve (e.g., "./src").
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    public Directory Directory(string path, bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, expand);
        var queryBuilder = QueryBuilder.Select("directory", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves entrypoint to be prepended to the arguments of all commands.
    /// </summary>
    public async Task<string> EntrypointAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("entrypoint", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves the value of the specified environment variable.
    /// </summary>
    /// <param name="name">
    /// The name of the environment variable to retrieve (e.g., "PATH").
    /// </param>
    public async Task<string> EnvVariableAsync(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("envVariable", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves the list of environment variables passed to commands.
    /// </summary>
    public async Task<EnvVariable> EnvVariablesAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("envVariables", arguments);
        return await Executor.Execute<EnvVariable>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The exit code of the last executed command.
    /// Returns an error if no command was set.
    /// </summary>
    public async Task<int> ExitCodeAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("exitCode", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// EXPERIMENTAL API! Subject to change/removal at any time.
    /// Configures all available GPUs on the host to be accessible to this container.
    /// This currently works for Nvidia devices only.
    /// </summary>
    public Container ExperimentalWithAllGPUs()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("experimentalWithAllGPUs", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// EXPERIMENTAL API! Subject to change/removal at any time.
    /// Configures the provided list of devices to be accessible to this container.
    /// This currently works for Nvidia devices only.
    /// </summary>
    /// <param name="devices">
    /// List of devices to be accessible to this container.
    /// </param>
    public Container ExperimentalWithGPU(string[] devices)
    {
        var arguments = ArgumentsBuilder.GetArguments(devices);
        var queryBuilder = QueryBuilder.Select("experimentalWithGPU", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Writes the container as an OCI tarball to the destination file path on the host.
    /// It can also export platform variants.
    /// </summary>
    /// <param name="path">
    /// Host's destination path (e.g., "./tarball").
    /// Path can be relative to the engine's workdir or absolute.
    /// </param>
    /// <param name="platformVariants">
    /// Identifiers for other platform specific containers.
    /// Used for multi-platform image.
    /// </param>
    /// <param name="forcedCompression">
    /// Force each layer of the exported image to use the specified compression algorithm.
    /// If this is unset, then if a layer already has a compressed blob in the engine's cache, that will be used (this can result in a mix of compression algorithms for different layers). If this is unset and a layer has no compressed blob in the engine's cache, then it will be compressed using Gzip.
    /// </param>
    /// <param name="mediaTypes">
    /// Use the specified media types for the exported image's layers.
    /// Defaults to OCI, which is largely compatible with most recent container runtimes, but Docker may be needed for older runtimes without OCI support.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    public async Task<string> ExportAsync(string path, Container[]? platformVariants = null, ImageLayerCompression? forcedCompression = null, ImageMediaTypes? mediaTypes = ImageMediaTypes.OCIMediaTypes, bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, platformVariants, forcedCompression, mediaTypes, expand);
        var queryBuilder = QueryBuilder.Select("export", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves the list of exposed ports.
    /// This includes ports already exposed by the image, even if not explicitly added with dagger.
    /// </summary>
    public async Task<Port> ExposedPortsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("exposedPorts", arguments);
        return await Executor.Execute<Port>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves a file at the given path.
    /// Mounts are included.
    /// </summary>
    /// <param name="path">
    /// The path of the file to retrieve (e.g., "./README.md").
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    /// </param>
    public File File(string path, bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, expand);
        var queryBuilder = QueryBuilder.Select("file", arguments);
        return new File(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Initializes this container from a pulled base image.
    /// </summary>
    /// <param name="address">
    /// Image's address from its registry.
    /// Formatted as [host]/[user]/[repo]:[tag] (e.g., "docker.io/dagger/dagger:main").
    /// </param>
    public Container From(string address)
    {
        var arguments = ArgumentsBuilder.GetArguments(address);
        var queryBuilder = QueryBuilder.Select("from", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// A unique identifier for this Container.
    /// </summary>
    public async Task<ContainerID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<ContainerID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The unique image reference which can only be retrieved immediately after the 'Container.From' call.
    /// </summary>
    public async Task<string> ImageRefAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("imageRef", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Reads the container from an OCI tarball.
    /// </summary>
    /// <param name="source">
    /// File to read the container from.
    /// </param>
    /// <param name="tag">
    /// Identifies the tag to import from the archive, if the archive bundles multiple tags.
    /// </param>
    public Container Import(File source, string? tag = "")
    {
        var arguments = ArgumentsBuilder.GetArguments(source, tag);
        var queryBuilder = QueryBuilder.Select("import", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves the value of the specified label.
    /// </summary>
    /// <param name="name">
    /// The name of the label (e.g., "org.opencontainers.artifact.created").
    /// </param>
    public async Task<string> LabelAsync(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("label", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves the list of labels passed to container.
    /// </summary>
    public async Task<Label> LabelsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("labels", arguments);
        return await Executor.Execute<Label>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves the list of paths where a directory is mounted.
    /// </summary>
    public async Task<string> MountsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("mounts", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The platform this container executes and publishes as.
    /// </summary>
    public async Task<Platform> PlatformAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("platform", arguments);
        return await Executor.Execute<Platform>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Publishes this container as a new image to the specified address.
    /// Publish returns a fully qualified ref.
    /// It can also publish platform variants.
    /// </summary>
    /// <param name="address">
    /// Registry's address to publish the image to.
    /// Formatted as [host]/[user]/[repo]:[tag] (e.g. "docker.io/dagger/dagger:main").
    /// </param>
    /// <param name="platformVariants">
    /// Identifiers for other platform specific containers.
    /// Used for multi-platform image.
    /// </param>
    /// <param name="forcedCompression">
    /// Force each layer of the published image to use the specified compression algorithm.
    /// If this is unset, then if a layer already has a compressed blob in the engine's cache, that will be used (this can result in a mix of compression algorithms for different layers). If this is unset and a layer has no compressed blob in the engine's cache, then it will be compressed using Gzip.
    /// </param>
    /// <param name="mediaTypes">
    /// Use the specified media types for the published image's layers.
    /// Defaults to OCI, which is largely compatible with most recent registries, but Docker may be needed for older registries without OCI support.
    /// </param>
    public async Task<string> PublishAsync(string address, Container[]? platformVariants = null, ImageLayerCompression? forcedCompression = null, ImageMediaTypes? mediaTypes = ImageMediaTypes.OCIMediaTypes)
    {
        var arguments = ArgumentsBuilder.GetArguments(address, platformVariants, forcedCompression, mediaTypes);
        var queryBuilder = QueryBuilder.Select("publish", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves this container's root filesystem. Mounts are not included.
    /// </summary>
    public Directory Rootfs()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("rootfs", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The error stream of the last executed command.
    /// Returns an error if no command was set.
    /// </summary>
    public async Task<string> StderrAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("stderr", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The output stream of the last executed command.
    /// Returns an error if no command was set.
    /// </summary>
    public async Task<string> StdoutAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("stdout", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Forces evaluation of the pipeline in the engine.
    /// It doesn't run the default command if no exec has been set.
    /// </summary>
    public async Task<ContainerID> SyncAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sync", arguments);
        return await Executor.Execute<ContainerID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Opens an interactive terminal for this container using its configured default terminal command if not overridden by args (or sh as a fallback default).
    /// </summary>
    /// <param name="cmd">
    /// If set, override the container's default terminal command and invoke these command arguments instead.
    /// </param>
    /// <param name="experimentalPrivilegedNesting">
    /// Provides Dagger access to the executed command.
    /// Do not use this option unless you trust the command being executed; the command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
    /// </param>
    /// <param name="insecureRootCapabilities">
    /// Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
    /// </param>
    public Container Terminal(string[]? cmd = null, bool? experimentalPrivilegedNesting = false, bool? insecureRootCapabilities = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(cmd, experimentalPrivilegedNesting, insecureRootCapabilities);
        var queryBuilder = QueryBuilder.Select("terminal", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Starts a Service and creates a tunnel that forwards traffic from the caller's network to that service.
    /// Be sure to set any exposed ports before calling this api.
    /// </summary>
    /// <param name="ports">
    /// List of frontend/backend port mappings to forward.
    /// Frontend is the port accepting traffic on the host, backend is the service port.
    /// </param>
    /// <param name="random">
    /// Bind each tunnel port to a random port on the host.
    /// </param>
    public async Task<Void> UpAsync(PortForward[]? ports = null, bool? random = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(ports, random);
        var queryBuilder = QueryBuilder.Select("up", arguments);
        return await Executor.Execute<Void>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves the user to be set for all commands.
    /// </summary>
    public async Task<string> UserAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("user", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves this container plus the given OCI anotation.
    /// </summary>
    /// <param name="name">
    /// The name of the annotation.
    /// </param>
    /// <param name="value">
    /// The value of the annotation.
    /// </param>
    public Container WithAnnotation(string name, string value)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, value);
        var queryBuilder = QueryBuilder.Select("withAnnotation", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Configures default arguments for future commands.
    /// </summary>
    /// <param name="args">
    /// Arguments to prepend to future executions (e.g., ["-v", "--no-cache"]).
    /// </param>
    public Container WithDefaultArgs(string[] args)
    {
        var arguments = ArgumentsBuilder.GetArguments(args);
        var queryBuilder = QueryBuilder.Select("withDefaultArgs", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Set the default command to invoke for the container's terminal API.
    /// </summary>
    /// <param name="args">
    /// The args of the command.
    /// </param>
    /// <param name="experimentalPrivilegedNesting">
    /// Provides Dagger access to the executed command.
    /// Do not use this option unless you trust the command being executed; the command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
    /// </param>
    /// <param name="insecureRootCapabilities">
    /// Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
    /// </param>
    public Container WithDefaultTerminalCmd(string[] args, bool? experimentalPrivilegedNesting = false, bool? insecureRootCapabilities = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(args, experimentalPrivilegedNesting, insecureRootCapabilities);
        var queryBuilder = QueryBuilder.Select("withDefaultTerminalCmd", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus a directory written at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the written directory (e.g., "/tmp/directory").
    /// </param>
    /// <param name="directory">
    /// Identifier of the directory to write
    /// </param>
    /// <param name="exclude">
    /// Patterns to exclude in the written directory (e.g. ["node_modules/**", ".gitignore", ".git/"]).
    /// </param>
    /// <param name="include">
    /// Patterns to include in the written directory (e.g. ["*.go", "go.mod", "go.sum"]).
    /// </param>
    /// <param name="owner">
    /// A user:group to set for the directory and its contents.
    /// The user and group can either be an ID (1000:1000) or a name (foo:bar).
    /// If the group is omitted, it defaults to the same as the user.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    public Container WithDirectory(string path, Directory directory, string[]? exclude = null, string[]? include = null, string? owner = "", bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, directory, exclude, include, owner, expand);
        var queryBuilder = QueryBuilder.Select("withDirectory", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container but with a different command entrypoint.
    /// </summary>
    /// <param name="args">
    /// Entrypoint to use for future executions (e.g., ["go", "run"]).
    /// </param>
    /// <param name="keepDefaultArgs">
    /// Don't remove the default arguments when setting the entrypoint.
    /// </param>
    public Container WithEntrypoint(string[] args, bool? keepDefaultArgs = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(args, keepDefaultArgs);
        var queryBuilder = QueryBuilder.Select("withEntrypoint", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus the given environment variable.
    /// </summary>
    /// <param name="name">
    /// The name of the environment variable (e.g., "HOST").
    /// </param>
    /// <param name="value">
    /// The value of the environment variable. (e.g., "localhost").
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value according to the current environment variables defined in the container (e.g. "/opt/bin:$PATH").
    /// </param>
    public Container WithEnvVariable(string name, string value, bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, value, expand);
        var queryBuilder = QueryBuilder.Select("withEnvVariable", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container after executing the specified command inside it.
    /// </summary>
    /// <param name="args">
    /// Command to run instead of the container's default command (e.g., ["go", "run", "main.go"]).
    /// If empty, the container's default command is used.
    /// </param>
    /// <param name="useEntrypoint">
    /// If the container has an entrypoint, prepend it to the args.
    /// </param>
    /// <param name="stdin">
    /// Content to write to the command's standard input before closing (e.g., "Hello world").
    /// </param>
    /// <param name="redirectStdout">
    /// Redirect the command's standard output to a file in the container (e.g., "/tmp/stdout").
    /// </param>
    /// <param name="redirectStderr">
    /// Redirect the command's standard error to a file in the container (e.g., "/tmp/stderr").
    /// </param>
    /// <param name="expect">
    /// Exit codes this command is allowed to exit with without error
    /// </param>
    /// <param name="experimentalPrivilegedNesting">
    /// Provides Dagger access to the executed command.
    /// Do not use this option unless you trust the command being executed; the command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
    /// </param>
    /// <param name="insecureRootCapabilities">
    /// Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the args according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    /// <param name="noInit">
    /// If set, skip the automatic init process injected into containers by default.
    /// This should only be used if the user requires that their exec process be the pid 1 process in the container. Otherwise it may result in unexpected behavior.
    /// </param>
    public Container WithExec(string[] args, bool? useEntrypoint = false, string? stdin = "", string? redirectStdout = "", string? redirectStderr = "", ReturnType? expect = ReturnType.SUCCESS, bool? experimentalPrivilegedNesting = false, bool? insecureRootCapabilities = false, bool? expand = false, bool? noInit = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(args, useEntrypoint, stdin, redirectStdout, redirectStderr, expect, experimentalPrivilegedNesting, insecureRootCapabilities, expand, noInit);
        var queryBuilder = QueryBuilder.Select("withExec", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Expose a network port.
    /// Exposed ports serve two purposes:
    /// - For health checks and introspection, when running services
    /// - For setting the EXPOSE OCI field when publishing the container
    /// </summary>
    /// <param name="port">
    /// Port number to expose
    /// </param>
    /// <param name="protocol">
    /// Transport layer network protocol
    /// </param>
    /// <param name="description">
    /// Optional port description
    /// </param>
    /// <param name="experimentalSkipHealthcheck">
    /// Skip the health check when run as a service.
    /// </param>
    public Container WithExposedPort(int port, NetworkProtocol? protocol = NetworkProtocol.TCP, string? description = null, bool? experimentalSkipHealthcheck = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(port, protocol, description, experimentalSkipHealthcheck);
        var queryBuilder = QueryBuilder.Select("withExposedPort", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus the contents of the given file copied to the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the copied file (e.g., "/tmp/file.txt").
    /// </param>
    /// <param name="source">
    /// Identifier of the file to copy.
    /// </param>
    /// <param name="permissions">
    /// Permission given to the copied file (e.g., 0600).
    /// </param>
    /// <param name="owner">
    /// A user:group to set for the file.
    /// The user and group can either be an ID (1000:1000) or a name (foo:bar).
    /// If the group is omitted, it defaults to the same as the user.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    /// </param>
    public Container WithFile(string path, File source, int? permissions = null, string? owner = "", bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, source, permissions, owner, expand);
        var queryBuilder = QueryBuilder.Select("withFile", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus the contents of the given files copied to the given path.
    /// </summary>
    /// <param name="path">
    /// Location where copied files should be placed (e.g., "/src").
    /// </param>
    /// <param name="sources">
    /// Identifiers of the files to copy.
    /// </param>
    /// <param name="permissions">
    /// Permission given to the copied files (e.g., 0600).
    /// </param>
    /// <param name="owner">
    /// A user:group to set for the files.
    /// The user and group can either be an ID (1000:1000) or a name (foo:bar).
    /// If the group is omitted, it defaults to the same as the user.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    /// </param>
    public Container WithFiles(string path, File[] sources, int? permissions = null, string? owner = "", bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, sources, permissions, owner, expand);
        var queryBuilder = QueryBuilder.Select("withFiles", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus the given label.
    /// </summary>
    /// <param name="name">
    /// The name of the label (e.g., "org.opencontainers.artifact.created").
    /// </param>
    /// <param name="value">
    /// The value of the label (e.g., "2023-01-01T00:00:00Z").
    /// </param>
    public Container WithLabel(string name, string value)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, value);
        var queryBuilder = QueryBuilder.Select("withLabel", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus a cache volume mounted at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the cache directory (e.g., "/root/.npm").
    /// </param>
    /// <param name="cache">
    /// Identifier of the cache volume to mount.
    /// </param>
    /// <param name="source">
    /// Identifier of the directory to use as the cache volume's root.
    /// </param>
    /// <param name="sharing">
    /// Sharing mode of the cache volume.
    /// </param>
    /// <param name="owner">
    /// A user:group to set for the mounted cache directory.
    /// Note that this changes the ownership of the specified mount along with the initial filesystem provided by source (if any). It does not have any effect if/when the cache has already been created.
    /// The user and group can either be an ID (1000:1000) or a name (foo:bar).
    /// If the group is omitted, it defaults to the same as the user.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    public Container WithMountedCache(string path, CacheVolume cache, Directory? source = null, CacheSharingMode? sharing = CacheSharingMode.SHARED, string? owner = "", bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, cache, source, sharing, owner, expand);
        var queryBuilder = QueryBuilder.Select("withMountedCache", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus a directory mounted at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the mounted directory (e.g., "/mnt/directory").
    /// </param>
    /// <param name="source">
    /// Identifier of the mounted directory.
    /// </param>
    /// <param name="owner">
    /// A user:group to set for the mounted directory and its contents.
    /// The user and group can either be an ID (1000:1000) or a name (foo:bar).
    /// If the group is omitted, it defaults to the same as the user.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    public Container WithMountedDirectory(string path, Directory source, string? owner = "", bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, source, owner, expand);
        var queryBuilder = QueryBuilder.Select("withMountedDirectory", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus a file mounted at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the mounted file (e.g., "/tmp/file.txt").
    /// </param>
    /// <param name="source">
    /// Identifier of the mounted file.
    /// </param>
    /// <param name="owner">
    /// A user or user:group to set for the mounted file.
    /// The user and group can either be an ID (1000:1000) or a name (foo:bar).
    /// If the group is omitted, it defaults to the same as the user.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    /// </param>
    public Container WithMountedFile(string path, File source, string? owner = "", bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, source, owner, expand);
        var queryBuilder = QueryBuilder.Select("withMountedFile", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus a secret mounted into a file at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the secret file (e.g., "/tmp/secret.txt").
    /// </param>
    /// <param name="source">
    /// Identifier of the secret to mount.
    /// </param>
    /// <param name="owner">
    /// A user:group to set for the mounted secret.
    /// The user and group can either be an ID (1000:1000) or a name (foo:bar).
    /// If the group is omitted, it defaults to the same as the user.
    /// </param>
    /// <param name="mode">
    /// Permission given to the mounted secret (e.g., 0600).
    /// This option requires an owner to be set to be active.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    public Container WithMountedSecret(string path, Secret source, string? owner = "", int? mode = 256, bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, source, owner, mode, expand);
        var queryBuilder = QueryBuilder.Select("withMountedSecret", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus a temporary directory mounted at the given path. Any writes will be ephemeral to a single withExec call; they will not be persisted to subsequent withExecs.
    /// </summary>
    /// <param name="path">
    /// Location of the temporary directory (e.g., "/tmp/temp_dir").
    /// </param>
    /// <param name="size">
    /// Size of the temporary directory in bytes.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    public Container WithMountedTemp(string path, int? size = null, bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, size, expand);
        var queryBuilder = QueryBuilder.Select("withMountedTemp", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus a new file written at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the written file (e.g., "/tmp/file.txt").
    /// </param>
    /// <param name="contents">
    /// Content of the file to write (e.g., "Hello world!").
    /// </param>
    /// <param name="permissions">
    /// Permission given to the written file (e.g., 0600).
    /// </param>
    /// <param name="owner">
    /// A user:group to set for the file.
    /// The user and group can either be an ID (1000:1000) or a name (foo:bar).
    /// If the group is omitted, it defaults to the same as the user.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    /// </param>
    public Container WithNewFile(string path, string contents, int? permissions = 420, string? owner = "", bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, contents, permissions, owner, expand);
        var queryBuilder = QueryBuilder.Select("withNewFile", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container with a registry authentication for a given address.
    /// </summary>
    /// <param name="address">
    /// Registry's address to bind the authentication to.
    /// Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
    /// </param>
    /// <param name="username">
    /// The username of the registry's account (e.g., "Dagger").
    /// </param>
    /// <param name="secret">
    /// The API key, password or token to authenticate to this registry.
    /// </param>
    public Container WithRegistryAuth(string address, string username, Secret secret)
    {
        var arguments = ArgumentsBuilder.GetArguments(address, username, secret);
        var queryBuilder = QueryBuilder.Select("withRegistryAuth", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves the container with the given directory mounted to /.
    /// </summary>
    /// <param name="directory">
    /// Directory to mount.
    /// </param>
    public Container WithRootfs(Directory directory)
    {
        var arguments = ArgumentsBuilder.GetArguments(directory);
        var queryBuilder = QueryBuilder.Select("withRootfs", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus an env variable containing the given secret.
    /// </summary>
    /// <param name="name">
    /// The name of the secret variable (e.g., "API_SECRET").
    /// </param>
    /// <param name="secret">
    /// The identifier of the secret value.
    /// </param>
    public Container WithSecretVariable(string name, Secret secret)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, secret);
        var queryBuilder = QueryBuilder.Select("withSecretVariable", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Establish a runtime dependency on a service.
    /// The service will be started automatically when needed and detached when it is no longer needed, executing the default command if none is set.
    /// The service will be reachable from the container via the provided hostname alias.
    /// The service dependency will also convey to any files or directories produced by the container.
    /// </summary>
    /// <param name="alias">
    /// A name that can be used to reach the service from the container
    /// </param>
    /// <param name="service">
    /// Identifier of the service container
    /// </param>
    public Container WithServiceBinding(string alias, Service service)
    {
        var arguments = ArgumentsBuilder.GetArguments(alias, service);
        var queryBuilder = QueryBuilder.Select("withServiceBinding", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container plus a socket forwarded to the given Unix socket path.
    /// </summary>
    /// <param name="path">
    /// Location of the forwarded Unix socket (e.g., "/tmp/socket").
    /// </param>
    /// <param name="source">
    /// Identifier of the socket to forward.
    /// </param>
    /// <param name="owner">
    /// A user:group to set for the mounted socket.
    /// The user and group can either be an ID (1000:1000) or a name (foo:bar).
    /// If the group is omitted, it defaults to the same as the user.
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    public Container WithUnixSocket(string path, Socket source, string? owner = "", bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, source, owner, expand);
        var queryBuilder = QueryBuilder.Select("withUnixSocket", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container with a different command user.
    /// </summary>
    /// <param name="name">
    /// The user to set (e.g., "root").
    /// </param>
    public Container WithUser(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("withUser", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container with a different working directory.
    /// </summary>
    /// <param name="path">
    /// The path to set as the working directory (e.g., "/app").
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    public Container WithWorkdir(string path, bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, expand);
        var queryBuilder = QueryBuilder.Select("withWorkdir", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container minus the given OCI annotation.
    /// </summary>
    /// <param name="name">
    /// The name of the annotation.
    /// </param>
    public Container WithoutAnnotation(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("withoutAnnotation", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container with unset default arguments for future commands.
    /// </summary>
    public Container WithoutDefaultArgs()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("withoutDefaultArgs", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container with the directory at the given path removed.
    /// </summary>
    /// <param name="path">
    /// Location of the directory to remove (e.g., ".github/").
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    public Container WithoutDirectory(string path, bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, expand);
        var queryBuilder = QueryBuilder.Select("withoutDirectory", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container with an unset command entrypoint.
    /// </summary>
    /// <param name="keepDefaultArgs">
    /// Don't remove the default arguments when unsetting the entrypoint.
    /// </param>
    public Container WithoutEntrypoint(bool? keepDefaultArgs = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(keepDefaultArgs);
        var queryBuilder = QueryBuilder.Select("withoutEntrypoint", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container minus the given environment variable.
    /// </summary>
    /// <param name="name">
    /// The name of the environment variable (e.g., "HOST").
    /// </param>
    public Container WithoutEnvVariable(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("withoutEnvVariable", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Unexpose a previously exposed port.
    /// </summary>
    /// <param name="port">
    /// Port number to unexpose
    /// </param>
    /// <param name="protocol">
    /// Port protocol to unexpose
    /// </param>
    public Container WithoutExposedPort(int port, NetworkProtocol? protocol = NetworkProtocol.TCP)
    {
        var arguments = ArgumentsBuilder.GetArguments(port, protocol);
        var queryBuilder = QueryBuilder.Select("withoutExposedPort", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container with the file at the given path removed.
    /// </summary>
    /// <param name="path">
    /// Location of the file to remove (e.g., "/file.txt").
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    /// </param>
    public Container WithoutFile(string path, bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, expand);
        var queryBuilder = QueryBuilder.Select("withoutFile", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container with the files at the given paths removed.
    /// </summary>
    /// <param name="paths">
    /// Location of the files to remove (e.g., ["/file.txt"]).
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of paths according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    /// </param>
    public Container WithoutFiles(string[] paths, bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(paths, expand);
        var queryBuilder = QueryBuilder.Select("withoutFiles", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container minus the given environment label.
    /// </summary>
    /// <param name="name">
    /// The name of the label to remove (e.g., "org.opencontainers.artifact.created").
    /// </param>
    public Container WithoutLabel(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("withoutLabel", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container after unmounting everything at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the cache directory (e.g., "/root/.npm").
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    public Container WithoutMount(string path, bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, expand);
        var queryBuilder = QueryBuilder.Select("withoutMount", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container without the registry authentication of a given address.
    /// </summary>
    /// <param name="address">
    /// Registry's address to remove the authentication from.
    /// Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
    /// </param>
    public Container WithoutRegistryAuth(string address)
    {
        var arguments = ArgumentsBuilder.GetArguments(address);
        var queryBuilder = QueryBuilder.Select("withoutRegistryAuth", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container minus the given environment variable containing the secret.
    /// </summary>
    /// <param name="name">
    /// The name of the environment variable (e.g., "HOST").
    /// </param>
    public Container WithoutSecretVariable(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("withoutSecretVariable", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container with a previously added Unix socket removed.
    /// </summary>
    /// <param name="path">
    /// Location of the socket to remove (e.g., "/tmp/socket").
    /// </param>
    /// <param name="expand">
    /// Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    /// </param>
    public Container WithoutUnixSocket(string path, bool? expand = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, expand);
        var queryBuilder = QueryBuilder.Select("withoutUnixSocket", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container with an unset command user.
    /// Should default to root.
    /// </summary>
    public Container WithoutUser()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("withoutUser", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this container with an unset working directory.
    /// Should default to "/".
    /// </summary>
    public Container WithoutWorkdir()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("withoutWorkdir", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves the working directory for all commands.
    /// </summary>
    public async Task<string> WorkdirAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("workdir", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `ContainerID` scalar type represents an identifier for an object of type Container.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<ContainerID>))]
public class ContainerID : Scalar
{
}

/// <summary>
/// Reflective module API provided to functions at runtime.
/// </summary>
public partial class CurrentModule(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<CurrentModuleID>
{
    /// <summary>
    /// A unique identifier for this CurrentModule.
    /// </summary>
    public async Task<CurrentModuleID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<CurrentModuleID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the module being executed in
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The directory containing the module's source code loaded into the engine (plus any generated code that may have been created).
    /// </summary>
    public Directory Source()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("source", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a directory from the module's scratch working directory, including any changes that may have been made to it during module function execution.
    /// </summary>
    /// <param name="path">
    /// Location of the directory to access (e.g., ".").
    /// </param>
    /// <param name="exclude">
    /// Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
    /// </param>
    /// <param name="include">
    /// Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
    /// </param>
    public Directory Workdir(string path, string[]? exclude = null, string[]? include = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, exclude, include);
        var queryBuilder = QueryBuilder.Select("workdir", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a file from the module's scratch working directory, including any changes that may have been made to it during module function execution.Load a file from the module's scratch working directory, including any changes that may have been made to it during module function execution.
    /// </summary>
    /// <param name="path">
    /// Location of the file to retrieve (e.g., "README.md").
    /// </param>
    public File WorkdirFile(string path)
    {
        var arguments = ArgumentsBuilder.GetArguments(path);
        var queryBuilder = QueryBuilder.Select("workdirFile", arguments);
        return new File(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `CurrentModuleID` scalar type represents an identifier for an object of type CurrentModule.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<CurrentModuleID>))]
public class CurrentModuleID : Scalar
{
}

/// <summary>
/// A directory.
/// </summary>
public partial class Directory(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<DirectoryID>
{
    /// <summary>
    /// Load the directory as a Dagger module
    /// </summary>
    /// <param name="sourceRootPath">
    /// An optional subpath of the directory which contains the module's configuration file.
    /// This is needed when the module code is in a subdirectory but requires parent directories to be loaded in order to execute. For example, the module source code may need a go.mod, project.toml, package.json, etc. file from a parent directory.
    /// If not set, the module source code is loaded from the root of the directory.
    /// </param>
    /// <param name="engineVersion">
    /// The engine version to upgrade to.
    /// </param>
    public Module AsModule(string? sourceRootPath = ".", string? engineVersion = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(sourceRootPath, engineVersion);
        var queryBuilder = QueryBuilder.Select("asModule", arguments);
        return new Module(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Gets the difference between this directory and an another directory.
    /// </summary>
    /// <param name="other">
    /// Identifier of the directory to compare.
    /// </param>
    public Directory Diff(Directory other)
    {
        var arguments = ArgumentsBuilder.GetArguments(other);
        var queryBuilder = QueryBuilder.Select("diff", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Return the directory's digest. The format of the digest is not guaranteed to be stable between releases of Dagger. It is guaranteed to be stable between invocations of the same Dagger engine.
    /// </summary>
    public async Task<string> DigestAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("digest", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves a directory at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the directory to retrieve (e.g., "/src").
    /// </param>
    public Directory Directory_(string path)
    {
        var arguments = ArgumentsBuilder.GetArguments(path);
        var queryBuilder = QueryBuilder.Select("directory", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Builds a new Docker container from this directory.
    /// </summary>
    /// <param name="platform">
    /// The platform to build.
    /// </param>
    /// <param name="dockerfile">
    /// Path to the Dockerfile to use (e.g., "frontend.Dockerfile").
    /// </param>
    /// <param name="target">
    /// Target build stage to build.
    /// </param>
    /// <param name="buildArgs">
    /// Build arguments to use in the build.
    /// </param>
    /// <param name="secrets">
    /// Secrets to pass to the build.
    /// They will be mounted at /run/secrets/[secret-name].
    /// </param>
    public Container DockerBuild(Platform? platform = null, string? dockerfile = "Dockerfile", string? target = "", BuildArg[]? buildArgs = null, Secret[]? secrets = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(platform, dockerfile, target, buildArgs, secrets);
        var queryBuilder = QueryBuilder.Select("dockerBuild", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns a list of files and directories at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the directory to look at (e.g., "/src").
    /// </param>
    public async Task<string> EntriesAsync(string? path = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(path);
        var queryBuilder = QueryBuilder.Select("entries", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Writes the contents of the directory to a path on the host.
    /// </summary>
    /// <param name="path">
    /// Location of the copied directory (e.g., "logs/").
    /// </param>
    /// <param name="wipe">
    /// If true, then the host directory will be wiped clean before exporting so that it exactly matches the directory being exported; this means it will delete any files on the host that aren't in the exported dir. If false (the default), the contents of the directory will be merged with any existing contents of the host directory, leaving any existing files on the host that aren't in the exported directory alone.
    /// </param>
    public async Task<string> ExportAsync(string path, bool? wipe = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, wipe);
        var queryBuilder = QueryBuilder.Select("export", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves a file at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the file to retrieve (e.g., "README.md").
    /// </param>
    public File File(string path)
    {
        var arguments = ArgumentsBuilder.GetArguments(path);
        var queryBuilder = QueryBuilder.Select("file", arguments);
        return new File(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns a list of files and directories that matche the given pattern.
    /// </summary>
    /// <param name="pattern">
    /// Pattern to match (e.g., "*.md").
    /// </param>
    public async Task<string> GlobAsync(string pattern)
    {
        var arguments = ArgumentsBuilder.GetArguments(pattern);
        var queryBuilder = QueryBuilder.Select("glob", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this Directory.
    /// </summary>
    public async Task<DirectoryID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<DirectoryID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Force evaluation in the engine.
    /// </summary>
    public async Task<DirectoryID> SyncAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sync", arguments);
        return await Executor.Execute<DirectoryID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Opens an interactive terminal in new container with this directory mounted inside.
    /// </summary>
    /// <param name="cmd">
    /// If set, override the container's default terminal command and invoke these command arguments instead.
    /// </param>
    /// <param name="experimentalPrivilegedNesting">
    /// Provides Dagger access to the executed command.
    /// Do not use this option unless you trust the command being executed; the command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
    /// </param>
    /// <param name="insecureRootCapabilities">
    /// Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
    /// </param>
    /// <param name="container">
    /// If set, override the default container used for the terminal.
    /// </param>
    public Directory Terminal(string[]? cmd = null, bool? experimentalPrivilegedNesting = false, bool? insecureRootCapabilities = false, Container? container = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(cmd, experimentalPrivilegedNesting, insecureRootCapabilities, container);
        var queryBuilder = QueryBuilder.Select("terminal", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this directory plus a directory written at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the written directory (e.g., "/src/").
    /// </param>
    /// <param name="directory">
    /// Identifier of the directory to copy.
    /// </param>
    /// <param name="exclude">
    /// Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
    /// </param>
    /// <param name="include">
    /// Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
    /// </param>
    public Directory WithDirectory(string path, Directory directory, string[]? exclude = null, string[]? include = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, directory, exclude, include);
        var queryBuilder = QueryBuilder.Select("withDirectory", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this directory plus the contents of the given file copied to the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the copied file (e.g., "/file.txt").
    /// </param>
    /// <param name="source">
    /// Identifier of the file to copy.
    /// </param>
    /// <param name="permissions">
    /// Permission given to the copied file (e.g., 0600).
    /// </param>
    public Directory WithFile(string path, File source, int? permissions = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, source, permissions);
        var queryBuilder = QueryBuilder.Select("withFile", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this directory plus the contents of the given files copied to the given path.
    /// </summary>
    /// <param name="path">
    /// Location where copied files should be placed (e.g., "/src").
    /// </param>
    /// <param name="sources">
    /// Identifiers of the files to copy.
    /// </param>
    /// <param name="permissions">
    /// Permission given to the copied files (e.g., 0600).
    /// </param>
    public Directory WithFiles(string path, File[] sources, int? permissions = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, sources, permissions);
        var queryBuilder = QueryBuilder.Select("withFiles", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this directory plus a new directory created at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the directory created (e.g., "/logs").
    /// </param>
    /// <param name="permissions">
    /// Permission granted to the created directory (e.g., 0777).
    /// </param>
    public Directory WithNewDirectory(string path, int? permissions = 420)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, permissions);
        var queryBuilder = QueryBuilder.Select("withNewDirectory", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this directory plus a new file written at the given path.
    /// </summary>
    /// <param name="path">
    /// Location of the written file (e.g., "/file.txt").
    /// </param>
    /// <param name="contents">
    /// Content of the written file (e.g., "Hello world!").
    /// </param>
    /// <param name="permissions">
    /// Permission given to the copied file (e.g., 0600).
    /// </param>
    public Directory WithNewFile(string path, string contents, int? permissions = 420)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, contents, permissions);
        var queryBuilder = QueryBuilder.Select("withNewFile", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this directory with all file/dir timestamps set to the given time.
    /// </summary>
    /// <param name="timestamp">
    /// Timestamp to set dir/files in.
    /// Formatted in seconds following Unix epoch (e.g., 1672531199).
    /// </param>
    public Directory WithTimestamps(int timestamp)
    {
        var arguments = ArgumentsBuilder.GetArguments(timestamp);
        var queryBuilder = QueryBuilder.Select("withTimestamps", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this directory with the directory at the given path removed.
    /// </summary>
    /// <param name="path">
    /// Location of the directory to remove (e.g., ".github/").
    /// </param>
    public Directory WithoutDirectory(string path)
    {
        var arguments = ArgumentsBuilder.GetArguments(path);
        var queryBuilder = QueryBuilder.Select("withoutDirectory", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this directory with the file at the given path removed.
    /// </summary>
    /// <param name="path">
    /// Location of the file to remove (e.g., "/file.txt").
    /// </param>
    public Directory WithoutFile(string path)
    {
        var arguments = ArgumentsBuilder.GetArguments(path);
        var queryBuilder = QueryBuilder.Select("withoutFile", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this directory with the files at the given paths removed.
    /// </summary>
    /// <param name="paths">
    /// Location of the file to remove (e.g., ["/file.txt"]).
    /// </param>
    public Directory WithoutFiles(string[] paths)
    {
        var arguments = ArgumentsBuilder.GetArguments(paths);
        var queryBuilder = QueryBuilder.Select("withoutFiles", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `DirectoryID` scalar type represents an identifier for an object of type Directory.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<DirectoryID>))]
public class DirectoryID : Scalar
{
}

/// <summary>
/// The Dagger engine configuration and state
/// </summary>
public partial class Engine(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<EngineID>
{
    /// <summary>
    /// A unique identifier for this Engine.
    /// </summary>
    public async Task<EngineID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<EngineID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The local (on-disk) cache for the Dagger engine
    /// </summary>
    public EngineCache LocalCache()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("localCache", arguments);
        return new EngineCache(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// A cache storage for the Dagger engine
/// </summary>
public partial class EngineCache(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<EngineCacheID>
{
    /// <summary>
    /// The current set of entries in the cache
    /// </summary>
    /// <param name="key">
    /// </param>
    public EngineCacheEntrySet EntrySet(string? key = "")
    {
        var arguments = ArgumentsBuilder.GetArguments(key);
        var queryBuilder = QueryBuilder.Select("entrySet", arguments);
        return new EngineCacheEntrySet(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// A unique identifier for this EngineCache.
    /// </summary>
    public async Task<EngineCacheID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<EngineCacheID>(GraphQLClient, queryBuilder);
    }

    [ObsoleteAttribute("Use minFreeSpace instead.")]
    /// <summary>
    /// The maximum bytes to keep in the cache without pruning, after which automatic pruning may kick in.
    /// </summary>
    public async Task<int> KeepBytesAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("keepBytes", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The maximum bytes to keep in the cache without pruning.
    /// </summary>
    public async Task<int> MaxUsedSpaceAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("maxUsedSpace", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The target amount of free disk space the garbage collector will attempt to leave.
    /// </summary>
    public async Task<int> MinFreeSpaceAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("minFreeSpace", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Prune the cache of releaseable entries
    /// </summary>
    public async Task<Void> PruneAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("prune", arguments);
        return await Executor.Execute<Void>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// </summary>
    public async Task<int> ReservedSpaceAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("reservedSpace", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// An individual cache entry in a cache entry set
/// </summary>
public partial class EngineCacheEntry(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<EngineCacheEntryID>
{
    /// <summary>
    /// Whether the cache entry is actively being used.
    /// </summary>
    public async Task<bool> ActivelyUsedAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("activelyUsed", arguments);
        return await Executor.Execute<bool>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The time the cache entry was created, in Unix nanoseconds.
    /// </summary>
    public async Task<int> CreatedTimeUnixNanoAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("createdTimeUnixNano", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The description of the cache entry.
    /// </summary>
    public async Task<string> DescriptionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("description", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The disk space used by the cache entry.
    /// </summary>
    public async Task<int> DiskSpaceBytesAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("diskSpaceBytes", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this EngineCacheEntry.
    /// </summary>
    public async Task<EngineCacheEntryID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<EngineCacheEntryID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The most recent time the cache entry was used, in Unix nanoseconds.
    /// </summary>
    public async Task<int> MostRecentUseTimeUnixNanoAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("mostRecentUseTimeUnixNano", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `EngineCacheEntryID` scalar type represents an identifier for an object of type EngineCacheEntry.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<EngineCacheEntryID>))]
public class EngineCacheEntryID : Scalar
{
}

/// <summary>
/// A set of cache entries returned by a query to a cache
/// </summary>
public partial class EngineCacheEntrySet(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<EngineCacheEntrySetID>
{
    /// <summary>
    /// The total disk space used by the cache entries in this set.
    /// </summary>
    public async Task<int> DiskSpaceBytesAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("diskSpaceBytes", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The list of individual cache entries in the set
    /// </summary>
    public async Task<EngineCacheEntry> EntriesAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("entries", arguments);
        return await Executor.Execute<EngineCacheEntry>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The number of cache entries in this set.
    /// </summary>
    public async Task<int> EntryCountAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("entryCount", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this EngineCacheEntrySet.
    /// </summary>
    public async Task<EngineCacheEntrySetID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<EngineCacheEntrySetID>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `EngineCacheEntrySetID` scalar type represents an identifier for an object of type EngineCacheEntrySet.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<EngineCacheEntrySetID>))]
public class EngineCacheEntrySetID : Scalar
{
}

/// <summary>
/// The `EngineCacheID` scalar type represents an identifier for an object of type EngineCache.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<EngineCacheID>))]
public class EngineCacheID : Scalar
{
}

/// <summary>
/// The `EngineID` scalar type represents an identifier for an object of type Engine.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<EngineID>))]
public class EngineID : Scalar
{
}

/// <summary>
/// A definition of a custom enum defined in a Module.
/// </summary>
public partial class EnumTypeDef(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<EnumTypeDefID>
{
    /// <summary>
    /// A doc string for the enum, if any.
    /// </summary>
    public async Task<string> DescriptionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("description", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this EnumTypeDef.
    /// </summary>
    public async Task<EnumTypeDefID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<EnumTypeDefID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the enum.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The location of this enum declaration.
    /// </summary>
    public SourceMap SourceMap()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceMap", arguments);
        return new SourceMap(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// If this EnumTypeDef is associated with a Module, the name of the module. Unset otherwise.
    /// </summary>
    public async Task<string> SourceModuleNameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceModuleName", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The values of the enum.
    /// </summary>
    public async Task<EnumValueTypeDef> ValuesAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("values", arguments);
        return await Executor.Execute<EnumValueTypeDef>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `EnumTypeDefID` scalar type represents an identifier for an object of type EnumTypeDef.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<EnumTypeDefID>))]
public class EnumTypeDefID : Scalar
{
}

/// <summary>
/// A definition of a value in a custom enum defined in a Module.
/// </summary>
public partial class EnumValueTypeDef(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<EnumValueTypeDefID>
{
    /// <summary>
    /// A doc string for the enum value, if any.
    /// </summary>
    public async Task<string> DescriptionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("description", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this EnumValueTypeDef.
    /// </summary>
    public async Task<EnumValueTypeDefID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<EnumValueTypeDefID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the enum value.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The location of this enum value declaration.
    /// </summary>
    public SourceMap SourceMap()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceMap", arguments);
        return new SourceMap(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `EnumValueTypeDefID` scalar type represents an identifier for an object of type EnumValueTypeDef.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<EnumValueTypeDefID>))]
public class EnumValueTypeDefID : Scalar
{
}

/// <summary>
/// An environment variable name and value.
/// </summary>
public partial class EnvVariable(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<EnvVariableID>
{
    /// <summary>
    /// A unique identifier for this EnvVariable.
    /// </summary>
    public async Task<EnvVariableID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<EnvVariableID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The environment variable name.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The environment variable value.
    /// </summary>
    public async Task<string> ValueAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("value", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `EnvVariableID` scalar type represents an identifier for an object of type EnvVariable.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<EnvVariableID>))]
public class EnvVariableID : Scalar
{
}

/// <summary>
/// </summary>
public partial class Error(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<ErrorID>
{
    /// <summary>
    /// A unique identifier for this Error.
    /// </summary>
    public async Task<ErrorID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<ErrorID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A description of the error.
    /// </summary>
    public async Task<string> MessageAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("message", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `ErrorID` scalar type represents an identifier for an object of type Error.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<ErrorID>))]
public class ErrorID : Scalar
{
}

/// <summary>
/// A definition of a field on a custom object defined in a Module.
/// A field on an object has a static value, as opposed to a function on an object whose value is computed by invoking code (and can accept arguments).
/// </summary>
public partial class FieldTypeDef(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<FieldTypeDefID>
{
    /// <summary>
    /// A doc string for the field, if any.
    /// </summary>
    public async Task<string> DescriptionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("description", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this FieldTypeDef.
    /// </summary>
    public async Task<FieldTypeDefID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<FieldTypeDefID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the field in lowerCamelCase format.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The location of this field declaration.
    /// </summary>
    public SourceMap SourceMap()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceMap", arguments);
        return new SourceMap(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The type of the field.
    /// </summary>
    public TypeDef TypeDef()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("typeDef", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `FieldTypeDefID` scalar type represents an identifier for an object of type FieldTypeDef.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<FieldTypeDefID>))]
public class FieldTypeDefID : Scalar
{
}

/// <summary>
/// A file.
/// </summary>
public partial class File(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<FileID>
{
    /// <summary>
    /// Retrieves the contents of the file.
    /// </summary>
    public async Task<string> ContentsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("contents", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Return the file's digest. The format of the digest is not guaranteed to be stable between releases of Dagger. It is guaranteed to be stable between invocations of the same Dagger engine.
    /// </summary>
    /// <param name="excludeMetadata">
    /// If true, exclude metadata from the digest.
    /// </param>
    public async Task<string> DigestAsync(bool? excludeMetadata = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(excludeMetadata);
        var queryBuilder = QueryBuilder.Select("digest", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Writes the file to a file path on the host.
    /// </summary>
    /// <param name="path">
    /// Location of the written directory (e.g., "output.txt").
    /// </param>
    /// <param name="allowParentDirPath">
    /// If allowParentDirPath is true, the path argument can be a directory path, in which case the file will be created in that directory.
    /// </param>
    public async Task<string> ExportAsync(string path, bool? allowParentDirPath = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, allowParentDirPath);
        var queryBuilder = QueryBuilder.Select("export", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this File.
    /// </summary>
    public async Task<FileID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<FileID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves the name of the file.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves the size of the file, in bytes.
    /// </summary>
    public async Task<int> SizeAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("size", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Force evaluation in the engine.
    /// </summary>
    public async Task<FileID> SyncAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sync", arguments);
        return await Executor.Execute<FileID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves this file with its name set to the given name.
    /// </summary>
    /// <param name="name">
    /// Name to set file to.
    /// </param>
    public File WithName(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("withName", arguments);
        return new File(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves this file with its created/modified timestamps set to the given time.
    /// </summary>
    /// <param name="timestamp">
    /// Timestamp to set dir/files in.
    /// Formatted in seconds following Unix epoch (e.g., 1672531199).
    /// </param>
    public File WithTimestamps(int timestamp)
    {
        var arguments = ArgumentsBuilder.GetArguments(timestamp);
        var queryBuilder = QueryBuilder.Select("withTimestamps", arguments);
        return new File(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `FileID` scalar type represents an identifier for an object of type File.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<FileID>))]
public class FileID : Scalar
{
}

/// <summary>
/// The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<Float>))]
public class Float : Scalar
{
}

/// <summary>
/// Function represents a resolver provided by a Module.
/// A function always evaluates against a parent object and is given a set of named arguments.
/// </summary>
public partial class Function(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<FunctionID>
{
    /// <summary>
    /// Arguments accepted by the function, if any.
    /// </summary>
    public async Task<FunctionArg> ArgsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("args", arguments);
        return await Executor.Execute<FunctionArg>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A doc string for the function, if any.
    /// </summary>
    public async Task<string> DescriptionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("description", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this Function.
    /// </summary>
    public async Task<FunctionID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<FunctionID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the function.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The type returned by the function.
    /// </summary>
    public TypeDef ReturnType()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("returnType", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The location of this function declaration.
    /// </summary>
    public SourceMap SourceMap()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceMap", arguments);
        return new SourceMap(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns the function with the provided argument
    /// </summary>
    /// <param name="name">
    /// The name of the argument
    /// </param>
    /// <param name="typeDef">
    /// The type of the argument
    /// </param>
    /// <param name="description">
    /// A doc string for the argument, if any
    /// </param>
    /// <param name="defaultValue">
    /// A default value to use for this argument if not explicitly set by the caller, if any
    /// </param>
    /// <param name="defaultPath">
    /// If the argument is a Directory or File type, default to load path from context directory, relative to root directory.
    /// </param>
    /// <param name="ignore">
    /// Patterns to ignore when loading the contextual argument value.
    /// </param>
    /// <param name="sourceMap">
    /// </param>
    public Function WithArg(string name, TypeDef typeDef, string? description = "", JSON? defaultValue = null, string? defaultPath = "", string[]? ignore = null, SourceMap? sourceMap = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, typeDef, description, defaultValue, defaultPath, ignore, sourceMap);
        var queryBuilder = QueryBuilder.Select("withArg", arguments);
        return new Function(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns the function with the given doc string.
    /// </summary>
    /// <param name="description">
    /// The doc string to set.
    /// </param>
    public Function WithDescription(string description)
    {
        var arguments = ArgumentsBuilder.GetArguments(description);
        var queryBuilder = QueryBuilder.Select("withDescription", arguments);
        return new Function(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns the function with the given source map.
    /// </summary>
    /// <param name="sourceMap">
    /// The source map for the function definition.
    /// </param>
    public Function WithSourceMap(SourceMap sourceMap)
    {
        var arguments = ArgumentsBuilder.GetArguments(sourceMap);
        var queryBuilder = QueryBuilder.Select("withSourceMap", arguments);
        return new Function(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// An argument accepted by a function.
/// This is a specification for an argument at function definition time, not an argument passed at function call time.
/// </summary>
public partial class FunctionArg(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<FunctionArgID>
{
    /// <summary>
    /// Only applies to arguments of type File or Directory. If the argument is not set, load it from the given path in the context directory
    /// </summary>
    public async Task<string> DefaultPathAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("defaultPath", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A default value to use for this argument when not explicitly set by the caller, if any.
    /// </summary>
    public async Task<JSON> DefaultValueAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("defaultValue", arguments);
        return await Executor.Execute<JSON>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A doc string for the argument, if any.
    /// </summary>
    public async Task<string> DescriptionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("description", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this FunctionArg.
    /// </summary>
    public async Task<FunctionArgID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<FunctionArgID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Only applies to arguments of type Directory. The ignore patterns are applied to the input directory, and matching entries are filtered out, in a cache-efficient manner.
    /// </summary>
    public async Task<string> IgnoreAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("ignore", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the argument in lowerCamelCase format.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The location of this arg declaration.
    /// </summary>
    public SourceMap SourceMap()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceMap", arguments);
        return new SourceMap(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The type of the argument.
    /// </summary>
    public TypeDef TypeDef()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("typeDef", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `FunctionArgID` scalar type represents an identifier for an object of type FunctionArg.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<FunctionArgID>))]
public class FunctionArgID : Scalar
{
}

/// <summary>
/// An active function call.
/// </summary>
public partial class FunctionCall(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<FunctionCallID>
{
    /// <summary>
    /// A unique identifier for this FunctionCall.
    /// </summary>
    public async Task<FunctionCallID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<FunctionCallID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The argument values the function is being invoked with.
    /// </summary>
    public async Task<FunctionCallArgValue> InputArgsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("inputArgs", arguments);
        return await Executor.Execute<FunctionCallArgValue>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the function being called.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The value of the parent object of the function being called. If the function is top-level to the module, this is always an empty object.
    /// </summary>
    public async Task<JSON> ParentAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("parent", arguments);
        return await Executor.Execute<JSON>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the parent object of the function being called. If the function is top-level to the module, this is the name of the module.
    /// </summary>
    public async Task<string> ParentNameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("parentName", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Return an error from the function.
    /// </summary>
    /// <param name="error">
    /// The error to return.
    /// </param>
    public async Task<Void> ReturnErrorAsync(Error error)
    {
        var arguments = ArgumentsBuilder.GetArguments(error);
        var queryBuilder = QueryBuilder.Select("returnError", arguments);
        return await Executor.Execute<Void>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Set the return value of the function call to the provided value.
    /// </summary>
    /// <param name="value">
    /// JSON serialization of the return value.
    /// </param>
    public async Task<Void> ReturnValueAsync(JSON value)
    {
        var arguments = ArgumentsBuilder.GetArguments(value);
        var queryBuilder = QueryBuilder.Select("returnValue", arguments);
        return await Executor.Execute<Void>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// A value passed as a named argument to a function call.
/// </summary>
public partial class FunctionCallArgValue(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<FunctionCallArgValueID>
{
    /// <summary>
    /// A unique identifier for this FunctionCallArgValue.
    /// </summary>
    public async Task<FunctionCallArgValueID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<FunctionCallArgValueID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the argument.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The value of the argument represented as a JSON serialized string.
    /// </summary>
    public async Task<JSON> ValueAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("value", arguments);
        return await Executor.Execute<JSON>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `FunctionCallArgValueID` scalar type represents an identifier for an object of type FunctionCallArgValue.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<FunctionCallArgValueID>))]
public class FunctionCallArgValueID : Scalar
{
}

/// <summary>
/// The `FunctionCallID` scalar type represents an identifier for an object of type FunctionCall.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<FunctionCallID>))]
public class FunctionCallID : Scalar
{
}

/// <summary>
/// The `FunctionID` scalar type represents an identifier for an object of type Function.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<FunctionID>))]
public class FunctionID : Scalar
{
}

/// <summary>
/// The result of running an SDK's codegen.
/// </summary>
public partial class GeneratedCode(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<GeneratedCodeID>
{
    /// <summary>
    /// The directory containing the generated code.
    /// </summary>
    public Directory Code()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("code", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// A unique identifier for this GeneratedCode.
    /// </summary>
    public async Task<GeneratedCodeID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<GeneratedCodeID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// List of paths to mark generated in version control (i.e. .gitattributes).
    /// </summary>
    public async Task<string> VcsGeneratedPathsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("vcsGeneratedPaths", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// List of paths to ignore in version control (i.e. .gitignore).
    /// </summary>
    public async Task<string> VcsIgnoredPathsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("vcsIgnoredPaths", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Set the list of paths to mark generated in version control.
    /// </summary>
    /// <param name="paths">
    /// </param>
    public GeneratedCode WithVCSGeneratedPaths(string[] paths)
    {
        var arguments = ArgumentsBuilder.GetArguments(paths);
        var queryBuilder = QueryBuilder.Select("withVCSGeneratedPaths", arguments);
        return new GeneratedCode(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Set the list of paths to ignore in version control.
    /// </summary>
    /// <param name="paths">
    /// </param>
    public GeneratedCode WithVCSIgnoredPaths(string[] paths)
    {
        var arguments = ArgumentsBuilder.GetArguments(paths);
        var queryBuilder = QueryBuilder.Select("withVCSIgnoredPaths", arguments);
        return new GeneratedCode(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `GeneratedCodeID` scalar type represents an identifier for an object of type GeneratedCode.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<GeneratedCodeID>))]
public class GeneratedCodeID : Scalar
{
}

/// <summary>
/// Module source originating from a git repo.
/// </summary>
public partial class GitModuleSource(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<GitModuleSourceID>
{
    /// <summary>
    /// The ref to clone the root of the git repo from
    /// </summary>
    public async Task<string> CloneRefAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("cloneRef", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The resolved commit of the git repo this source points to.
    /// </summary>
    public async Task<string> CommitAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("commit", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The directory containing everything needed to load load and use the module.
    /// </summary>
    public Directory ContextDirectory()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("contextDirectory", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The URL to access the web view of the repository (e.g., GitHub, GitLab, Bitbucket)
    /// </summary>
    public async Task<string> HtmlRepoURLAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("htmlRepoURL", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The URL to the source's git repo in a web browser
    /// </summary>
    public async Task<string> HtmlURLAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("htmlURL", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this GitModuleSource.
    /// </summary>
    public async Task<GitModuleSourceID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<GitModuleSourceID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The clean module name of the root of the module
    /// </summary>
    public async Task<string> RootAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("root", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The path to the root of the module source under the context directory. This directory contains its configuration file. It also contains its source code (possibly as a subdirectory).
    /// </summary>
    public async Task<string> RootSubpathAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("rootSubpath", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The specified version of the git repo this source points to.
    /// </summary>
    public async Task<string> VersionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("version", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `GitModuleSourceID` scalar type represents an identifier for an object of type GitModuleSource.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<GitModuleSourceID>))]
public class GitModuleSourceID : Scalar
{
}

/// <summary>
/// A git ref (tag, branch, or commit).
/// </summary>
public partial class GitRef(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<GitRefID>
{
    /// <summary>
    /// The resolved commit id at this ref.
    /// </summary>
    public async Task<string> CommitAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("commit", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this GitRef.
    /// </summary>
    public async Task<GitRefID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<GitRefID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The filesystem tree at this ref.
    /// </summary>
    /// <param name="discardGitDir">
    /// Set to true to discard .git directory.
    /// </param>
    public Directory Tree(bool? discardGitDir = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(discardGitDir);
        var queryBuilder = QueryBuilder.Select("tree", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `GitRefID` scalar type represents an identifier for an object of type GitRef.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<GitRefID>))]
public class GitRefID : Scalar
{
}

/// <summary>
/// A git repository.
/// </summary>
public partial class GitRepository(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<GitRepositoryID>
{
    /// <summary>
    /// Returns details of a branch.
    /// </summary>
    /// <param name="name">
    /// Branch's name (e.g., "main").
    /// </param>
    public GitRef Branch(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("branch", arguments);
        return new GitRef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns details of a commit.
    /// </summary>
    /// <param name="id">
    /// Identifier of the commit (e.g., "b6315d8f2810962c601af73f86831f6866ea798b").
    /// </param>
    public GitRef Commit(string id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("commit", arguments);
        return new GitRef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns details for HEAD.
    /// </summary>
    public GitRef Head()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("head", arguments);
        return new GitRef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// A unique identifier for this GitRepository.
    /// </summary>
    public async Task<GitRepositoryID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<GitRepositoryID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Returns details of a ref.
    /// </summary>
    /// <param name="name">
    /// Ref's name (can be a commit identifier, a tag name, a branch name, or a fully-qualified ref).
    /// </param>
    public GitRef Ref(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("ref", arguments);
        return new GitRef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns details of a tag.
    /// </summary>
    /// <param name="name">
    /// Tag's name (e.g., "v0.3.9").
    /// </param>
    public GitRef Tag(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("tag", arguments);
        return new GitRef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// tags that match any of the given glob patterns.
    /// </summary>
    /// <param name="patterns">
    /// Glob patterns (e.g., "refs/tags/v*").
    /// </param>
    public async Task<string> TagsAsync(string[]? patterns = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(patterns);
        var queryBuilder = QueryBuilder.Select("tags", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Header to authenticate the remote with.
    /// </summary>
    /// <param name="header">
    /// Secret used to populate the Authorization HTTP header
    /// </param>
    public GitRepository WithAuthHeader(Secret header)
    {
        var arguments = ArgumentsBuilder.GetArguments(header);
        var queryBuilder = QueryBuilder.Select("withAuthHeader", arguments);
        return new GitRepository(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Token to authenticate the remote with.
    /// </summary>
    /// <param name="token">
    /// Secret used to populate the password during basic HTTP Authorization
    /// </param>
    public GitRepository WithAuthToken(Secret token)
    {
        var arguments = ArgumentsBuilder.GetArguments(token);
        var queryBuilder = QueryBuilder.Select("withAuthToken", arguments);
        return new GitRepository(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `GitRepositoryID` scalar type represents an identifier for an object of type GitRepository.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<GitRepositoryID>))]
public class GitRepositoryID : Scalar
{
}

/// <summary>
/// Information about the host environment.
/// </summary>
public partial class Host(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<HostID>
{
    /// <summary>
    /// Accesses a directory on the host.
    /// </summary>
    /// <param name="path">
    /// Location of the directory to access (e.g., ".").
    /// </param>
    /// <param name="exclude">
    /// Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
    /// </param>
    /// <param name="include">
    /// Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
    /// </param>
    public Directory Directory(string path, string[]? exclude = null, string[]? include = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, exclude, include);
        var queryBuilder = QueryBuilder.Select("directory", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Accesses a file on the host.
    /// </summary>
    /// <param name="path">
    /// Location of the file to retrieve (e.g., "README.md").
    /// </param>
    public File File(string path)
    {
        var arguments = ArgumentsBuilder.GetArguments(path);
        var queryBuilder = QueryBuilder.Select("file", arguments);
        return new File(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// A unique identifier for this Host.
    /// </summary>
    public async Task<HostID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<HostID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Creates a service that forwards traffic to a specified address via the host.
    /// </summary>
    /// <param name="host">
    /// Upstream host to forward traffic to.
    /// </param>
    /// <param name="ports">
    /// Ports to expose via the service, forwarding through the host network.
    /// If a port's frontend is unspecified or 0, it defaults to the same as the backend port.
    /// An empty set of ports is not valid; an error will be returned.
    /// </param>
    public Service Service(PortForward[] ports, string? host = "localhost")
    {
        var arguments = ArgumentsBuilder.GetArguments(host, ports);
        var queryBuilder = QueryBuilder.Select("service", arguments);
        return new Service(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Sets a secret given a user-defined name and the file path on the host, and returns the secret.
    /// The file is limited to a size of 512000 bytes.
    /// </summary>
    /// <param name="name">
    /// The user defined name for this secret.
    /// </param>
    /// <param name="path">
    /// Location of the file to set as a secret.
    /// </param>
    public Secret SetSecretFile(string name, string path)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, path);
        var queryBuilder = QueryBuilder.Select("setSecretFile", arguments);
        return new Secret(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Creates a tunnel that forwards traffic from the host to a service.
    /// </summary>
    /// <param name="service">
    /// Service to send traffic from the tunnel.
    /// </param>
    /// <param name="ports">
    /// Configure explicit port forwarding rules for the tunnel.
    /// If a port's frontend is unspecified or 0, a random port will be chosen by the host.
    /// If no ports are given, all of the service's ports are forwarded. If native is true, each port maps to the same port on the host. If native is false, each port maps to a random port chosen by the host.
    /// If ports are given and native is true, the ports are additive.
    /// </param>
    /// <param name="native">
    /// Map each service port to the same port on the host, as if the service were running natively.
    /// Note: enabling may result in port conflicts.
    /// </param>
    public Service Tunnel(Service service, PortForward[]? ports = null, bool? native = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(service, ports, native);
        var queryBuilder = QueryBuilder.Select("tunnel", arguments);
        return new Service(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Accesses a Unix socket on the host.
    /// </summary>
    /// <param name="path">
    /// Location of the Unix socket (e.g., "/var/run/docker.sock").
    /// </param>
    public Socket UnixSocket(string path)
    {
        var arguments = ArgumentsBuilder.GetArguments(path);
        var queryBuilder = QueryBuilder.Select("unixSocket", arguments);
        return new Socket(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `HostID` scalar type represents an identifier for an object of type Host.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<HostID>))]
public class HostID : Scalar
{
}

/// <summary>
/// Compression algorithm to use for image layers.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter<ImageLayerCompression>))]
public enum ImageLayerCompression
{
    /// <summary>
    /// </summary>
    Gzip,
    /// <summary>
    /// </summary>
    Zstd,
    /// <summary>
    /// </summary>
    EStarGZ,
    /// <summary>
    /// </summary>
    Uncompressed
}

/// <summary>
/// Mediatypes to use in published or exported image metadata.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter<ImageMediaTypes>))]
public enum ImageMediaTypes
{
    /// <summary>
    /// </summary>
    OCIMediaTypes,
    /// <summary>
    /// </summary>
    DockerMediaTypes
}

/// <summary>
/// A graphql input type, which is essentially just a group of named args.
/// This is currently only used to represent pre-existing usage of graphql input types
/// in the core API. It is not used by user modules and shouldn't ever be as user
/// module accept input objects via their id rather than graphql input types.
/// </summary>
public partial class InputTypeDef(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<InputTypeDefID>
{
    /// <summary>
    /// Static fields defined on this input object, if any.
    /// </summary>
    public async Task<FieldTypeDef> FieldsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("fields", arguments);
        return await Executor.Execute<FieldTypeDef>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this InputTypeDef.
    /// </summary>
    public async Task<InputTypeDefID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<InputTypeDefID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the input object.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `InputTypeDefID` scalar type represents an identifier for an object of type InputTypeDef.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<InputTypeDefID>))]
public class InputTypeDefID : Scalar
{
}

/// <summary>
/// The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<Int>))]
public class Int : Scalar
{
}

/// <summary>
/// A definition of a custom interface defined in a Module.
/// </summary>
public partial class InterfaceTypeDef(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<InterfaceTypeDefID>
{
    /// <summary>
    /// The doc string for the interface, if any.
    /// </summary>
    public async Task<string> DescriptionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("description", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Functions defined on this interface, if any.
    /// </summary>
    public async Task<Function> FunctionsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("functions", arguments);
        return await Executor.Execute<Function>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this InterfaceTypeDef.
    /// </summary>
    public async Task<InterfaceTypeDefID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<InterfaceTypeDefID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the interface.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The location of this interface declaration.
    /// </summary>
    public SourceMap SourceMap()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceMap", arguments);
        return new SourceMap(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// If this InterfaceTypeDef is associated with a Module, the name of the module. Unset otherwise.
    /// </summary>
    public async Task<string> SourceModuleNameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceModuleName", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `InterfaceTypeDefID` scalar type represents an identifier for an object of type InterfaceTypeDef.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<InterfaceTypeDefID>))]
public class InterfaceTypeDefID : Scalar
{
}

/// <summary>
/// An arbitrary JSON-encoded value.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<JSON>))]
public class JSON : Scalar
{
}

/// <summary>
/// A simple key value object that represents a label.
/// </summary>
public partial class Label(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<LabelID>
{
    /// <summary>
    /// A unique identifier for this Label.
    /// </summary>
    public async Task<LabelID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<LabelID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The label name.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The label value.
    /// </summary>
    public async Task<string> ValueAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("value", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `LabelID` scalar type represents an identifier for an object of type Label.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<LabelID>))]
public class LabelID : Scalar
{
}

/// <summary>
/// A definition of a list type in a Module.
/// </summary>
public partial class ListTypeDef(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<ListTypeDefID>
{
    /// <summary>
    /// The type of the elements in the list.
    /// </summary>
    public TypeDef ElementTypeDef()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("elementTypeDef", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// A unique identifier for this ListTypeDef.
    /// </summary>
    public async Task<ListTypeDefID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<ListTypeDefID>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `ListTypeDefID` scalar type represents an identifier for an object of type ListTypeDef.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<ListTypeDefID>))]
public class ListTypeDefID : Scalar
{
}

/// <summary>
/// Module source that that originates from a path locally relative to an arbitrary directory.
/// </summary>
public partial class LocalModuleSource(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<LocalModuleSourceID>
{
    /// <summary>
    /// The directory containing everything needed to load load and use the module.
    /// </summary>
    public Directory ContextDirectory()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("contextDirectory", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// A unique identifier for this LocalModuleSource.
    /// </summary>
    public async Task<LocalModuleSourceID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<LocalModuleSourceID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The relative path to the module root from the host directory
    /// </summary>
    public async Task<string> RelHostPathAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("relHostPath", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The path to the root of the module source under the context directory. This directory contains its configuration file. It also contains its source code (possibly as a subdirectory).
    /// </summary>
    public async Task<string> RootSubpathAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("rootSubpath", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `LocalModuleSourceID` scalar type represents an identifier for an object of type LocalModuleSource.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<LocalModuleSourceID>))]
public class LocalModuleSourceID : Scalar
{
}

/// <summary>
/// A Dagger module.
/// </summary>
public partial class Module(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<ModuleID>
{
    /// <summary>
    /// Modules used by this module.
    /// </summary>
    public async Task<Module> DependenciesAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("dependencies", arguments);
        return await Executor.Execute<Module>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The dependencies as configured by the module.
    /// </summary>
    public async Task<ModuleDependency> DependencyConfigAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("dependencyConfig", arguments);
        return await Executor.Execute<ModuleDependency>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The doc string of the module, if any
    /// </summary>
    public async Task<string> DescriptionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("description", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Enumerations served by this module.
    /// </summary>
    public async Task<TypeDef> EnumsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("enums", arguments);
        return await Executor.Execute<TypeDef>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The generated files and directories made on top of the module source's context directory.
    /// </summary>
    public Directory GeneratedContextDiff()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("generatedContextDiff", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The module source's context plus any configuration and source files created by codegen.
    /// </summary>
    public Directory GeneratedContextDirectory()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("generatedContextDirectory", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// A unique identifier for this Module.
    /// </summary>
    public async Task<ModuleID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<ModuleID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves the module with the objects loaded via its SDK.
    /// </summary>
    public Module Initialize()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("initialize", arguments);
        return new Module(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Interfaces served by this module.
    /// </summary>
    public async Task<TypeDef> InterfacesAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("interfaces", arguments);
        return await Executor.Execute<TypeDef>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the module
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Objects served by this module.
    /// </summary>
    public async Task<TypeDef> ObjectsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("objects", arguments);
        return await Executor.Execute<TypeDef>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The container that runs the module's entrypoint. It will fail to execute if the module doesn't compile.
    /// </summary>
    public Container Runtime()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("runtime", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The SDK used by this module. Either a name of a builtin SDK or a module source ref string pointing to the SDK's implementation.
    /// </summary>
    public async Task<string> SdkAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sdk", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Serve a module's API in the current session.
    /// Note: this can only be called once per session. In the future, it could return a stream or service to remove the side effect.
    /// </summary>
    public async Task<Void> ServeAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("serve", arguments);
        return await Executor.Execute<Void>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The source for the module.
    /// </summary>
    public ModuleSource Source()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("source", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves the module with the given description
    /// </summary>
    /// <param name="description">
    /// The description to set
    /// </param>
    public Module WithDescription(string description)
    {
        var arguments = ArgumentsBuilder.GetArguments(description);
        var queryBuilder = QueryBuilder.Select("withDescription", arguments);
        return new Module(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// This module plus the given Enum type and associated values
    /// </summary>
    /// <param name="enum">
    /// </param>
    public Module WithEnum(TypeDef @enum)
    {
        var arguments = ArgumentsBuilder.GetArguments(@enum);
        var queryBuilder = QueryBuilder.Select("withEnum", arguments);
        return new Module(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// This module plus the given Interface type and associated functions
    /// </summary>
    /// <param name="iface">
    /// </param>
    public Module WithInterface(TypeDef iface)
    {
        var arguments = ArgumentsBuilder.GetArguments(iface);
        var queryBuilder = QueryBuilder.Select("withInterface", arguments);
        return new Module(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// This module plus the given Object type and associated functions.
    /// </summary>
    /// <param name="object">
    /// </param>
    public Module WithObject(TypeDef @object)
    {
        var arguments = ArgumentsBuilder.GetArguments(@object);
        var queryBuilder = QueryBuilder.Select("withObject", arguments);
        return new Module(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves the module with basic configuration loaded if present.
    /// </summary>
    /// <param name="source">
    /// The module source to initialize from.
    /// </param>
    /// <param name="engineVersion">
    /// The engine version to upgrade to.
    /// </param>
    public Module WithSource(ModuleSource source, string? engineVersion = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(source, engineVersion);
        var queryBuilder = QueryBuilder.Select("withSource", arguments);
        return new Module(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The configuration of dependency of a module.
/// </summary>
public partial class ModuleDependency(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<ModuleDependencyID>
{
    /// <summary>
    /// A unique identifier for this ModuleDependency.
    /// </summary>
    public async Task<ModuleDependencyID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<ModuleDependencyID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the dependency module.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The source for the dependency module.
    /// </summary>
    public ModuleSource Source()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("source", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `ModuleDependencyID` scalar type represents an identifier for an object of type ModuleDependency.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<ModuleDependencyID>))]
public class ModuleDependencyID : Scalar
{
}

/// <summary>
/// The `ModuleID` scalar type represents an identifier for an object of type Module.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<ModuleID>))]
public class ModuleID : Scalar
{
}

/// <summary>
/// The source needed to load and run a module, along with any metadata about the source such as versions/urls/etc.
/// </summary>
public partial class ModuleSource(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<ModuleSourceID>
{
    /// <summary>
    /// If the source is a of kind git, the git source representation of it.
    /// </summary>
    public GitModuleSource AsGitSource()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("asGitSource", arguments);
        return new GitModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// If the source is of kind local, the local source representation of it.
    /// </summary>
    public LocalModuleSource AsLocalSource()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("asLocalSource", arguments);
        return new LocalModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load the source as a module. If this is a local source, the parent directory must have been provided during module source creation
    /// </summary>
    /// <param name="engineVersion">
    /// The engine version to upgrade to.
    /// </param>
    public Module AsModule(string? engineVersion = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(engineVersion);
        var queryBuilder = QueryBuilder.Select("asModule", arguments);
        return new Module(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// A human readable ref string representation of this module source.
    /// </summary>
    public async Task<string> AsStringAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("asString", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Returns whether the module source has a configuration file.
    /// </summary>
    public async Task<bool> ConfigExistsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("configExists", arguments);
        return await Executor.Execute<bool>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The directory containing everything needed to load and use the module.
    /// </summary>
    public Directory ContextDirectory()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("contextDirectory", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The effective module source dependencies from the configuration, and calls to withDependencies and withoutDependencies.
    /// </summary>
    public async Task<ModuleDependency> DependenciesAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("dependencies", arguments);
        return await Executor.Execute<ModuleDependency>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Return the module source's content digest. The format of the digest is not guaranteed to be stable between releases of Dagger. It is guaranteed to be stable between invocations of the same Dagger engine.
    /// </summary>
    public async Task<string> DigestAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("digest", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The directory containing the module configuration and source code (source code may be in a subdir).
    /// </summary>
    /// <param name="path">
    /// The path from the source directory to select.
    /// </param>
    public Directory Directory(string path)
    {
        var arguments = ArgumentsBuilder.GetArguments(path);
        var queryBuilder = QueryBuilder.Select("directory", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// A unique identifier for this ModuleSource.
    /// </summary>
    public async Task<ModuleSourceID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<ModuleSourceID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The kind of source (e.g. local, git, etc.)
    /// </summary>
    public async Task<ModuleSourceKind> KindAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("kind", arguments);
        return await Executor.Execute<ModuleSourceKind>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// If set, the name of the module this source references, including any overrides at runtime by callers.
    /// </summary>
    public async Task<string> ModuleNameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("moduleName", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The original name of the module this source references, as defined in the module configuration.
    /// </summary>
    public async Task<string> ModuleOriginalNameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("moduleOriginalName", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The pinned version of this module source.
    /// </summary>
    public async Task<string> PinAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("pin", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The path to the module source's context directory on the caller's filesystem. Only valid for local sources.
    /// </summary>
    public async Task<string> ResolveContextPathFromCallerAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("resolveContextPathFromCaller", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Resolve the provided module source arg as a dependency relative to this module source.
    /// </summary>
    /// <param name="dep">
    /// The dependency module source to resolve.
    /// </param>
    public ModuleSource ResolveDependency(ModuleSource dep)
    {
        var arguments = ArgumentsBuilder.GetArguments(dep);
        var queryBuilder = QueryBuilder.Select("resolveDependency", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a directory from the caller optionally with a given view applied.
    /// </summary>
    /// <param name="path">
    /// The path on the caller's filesystem to load.
    /// </param>
    /// <param name="viewName">
    /// If set, the name of the view to apply to the path.
    /// </param>
    /// <param name="ignore">
    /// Patterns to ignore when loading the directory.
    /// </param>
    public Directory ResolveDirectoryFromCaller(string path, string? viewName = null, string[]? ignore = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(path, viewName, ignore);
        var queryBuilder = QueryBuilder.Select("resolveDirectoryFromCaller", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load the source from its path on the caller's filesystem, including only needed+configured files and directories. Only valid for local sources.
    /// </summary>
    public ModuleSource ResolveFromCaller()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("resolveFromCaller", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The path relative to context of the root of the module source, which contains dagger.json. It also contains the module implementation source code, but that may or may not being a subdir of this root.
    /// </summary>
    public async Task<string> SourceRootSubpathAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceRootSubpath", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The path relative to context of the module implementation source code.
    /// </summary>
    public async Task<string> SourceSubpathAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceSubpath", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieve a named view defined for this module source.
    /// </summary>
    /// <param name="name">
    /// The name of the view to retrieve.
    /// </param>
    public ModuleSourceView View(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("view", arguments);
        return new ModuleSourceView(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The named views defined for this module source, which are sets of directory filters that can be applied to directory arguments provided to functions.
    /// </summary>
    public async Task<ModuleSourceView> ViewsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("views", arguments);
        return await Executor.Execute<ModuleSourceView>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Update the module source with a new context directory. Only valid for local sources.
    /// </summary>
    /// <param name="dir">
    /// The directory to set as the context directory.
    /// </param>
    public ModuleSource WithContextDirectory(Directory dir)
    {
        var arguments = ArgumentsBuilder.GetArguments(dir);
        var queryBuilder = QueryBuilder.Select("withContextDirectory", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Append the provided dependencies to the module source's dependency list.
    /// </summary>
    /// <param name="dependencies">
    /// The dependencies to append.
    /// </param>
    public ModuleSource WithDependencies(ModuleDependency[] dependencies)
    {
        var arguments = ArgumentsBuilder.GetArguments(dependencies);
        var queryBuilder = QueryBuilder.Select("withDependencies", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Sets module init arguments
    /// </summary>
    /// <param name="merge">
    /// Merge module dependencies into the current project's
    /// </param>
    public ModuleSource WithInit(bool? merge = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(merge);
        var queryBuilder = QueryBuilder.Select("withInit", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Update the module source with a new name.
    /// </summary>
    /// <param name="name">
    /// The name to set.
    /// </param>
    public ModuleSource WithName(string name)
    {
        var arguments = ArgumentsBuilder.GetArguments(name);
        var queryBuilder = QueryBuilder.Select("withName", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Update the module source with a new SDK.
    /// </summary>
    /// <param name="sdk">
    /// The SDK to set.
    /// </param>
    public ModuleSource WithSDK(string sdk)
    {
        var arguments = ArgumentsBuilder.GetArguments(sdk);
        var queryBuilder = QueryBuilder.Select("withSDK", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Update the module source with a new source subpath.
    /// </summary>
    /// <param name="path">
    /// The path to set as the source subpath.
    /// </param>
    public ModuleSource WithSourceSubpath(string path)
    {
        var arguments = ArgumentsBuilder.GetArguments(path);
        var queryBuilder = QueryBuilder.Select("withSourceSubpath", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Update the module source with a new named view.
    /// </summary>
    /// <param name="name">
    /// The name of the view to set.
    /// </param>
    /// <param name="patterns">
    /// The patterns to set as the view filters.
    /// </param>
    public ModuleSource WithView(string name, string[] patterns)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, patterns);
        var queryBuilder = QueryBuilder.Select("withView", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Remove the provided dependencies from the module source's dependency list.
    /// </summary>
    /// <param name="dependencies">
    /// The dependencies to remove.
    /// </param>
    public ModuleSource WithoutDependencies(string[] dependencies)
    {
        var arguments = ArgumentsBuilder.GetArguments(dependencies);
        var queryBuilder = QueryBuilder.Select("withoutDependencies", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `ModuleSourceID` scalar type represents an identifier for an object of type ModuleSource.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<ModuleSourceID>))]
public class ModuleSourceID : Scalar
{
}

/// <summary>
/// The kind of module source.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter<ModuleSourceKind>))]
public enum ModuleSourceKind
{
    /// <summary>
    /// </summary>
    LOCAL_SOURCE,
    /// <summary>
    /// </summary>
    GIT_SOURCE
}

/// <summary>
/// A named set of path filters that can be applied to directory arguments provided to functions.
/// </summary>
public partial class ModuleSourceView(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<ModuleSourceViewID>
{
    /// <summary>
    /// A unique identifier for this ModuleSourceView.
    /// </summary>
    public async Task<ModuleSourceViewID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<ModuleSourceViewID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the view
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The patterns of the view used to filter paths
    /// </summary>
    public async Task<string> PatternsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("patterns", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `ModuleSourceViewID` scalar type represents an identifier for an object of type ModuleSourceView.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<ModuleSourceViewID>))]
public class ModuleSourceViewID : Scalar
{
}

/// <summary>
/// Transport layer network protocol associated to a port.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter<NetworkProtocol>))]
public enum NetworkProtocol
{
    /// <summary>
    /// </summary>
    TCP,
    /// <summary>
    /// </summary>
    UDP
}

/// <summary>
/// A definition of a custom object defined in a Module.
/// </summary>
public partial class ObjectTypeDef(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<ObjectTypeDefID>
{
    /// <summary>
    /// The function used to construct new instances of this object, if any
    /// </summary>
    public Function Constructor()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("constructor", arguments);
        return new Function(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The doc string for the object, if any.
    /// </summary>
    public async Task<string> DescriptionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("description", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Static fields defined on this object, if any.
    /// </summary>
    public async Task<FieldTypeDef> FieldsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("fields", arguments);
        return await Executor.Execute<FieldTypeDef>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Functions defined on this object, if any.
    /// </summary>
    public async Task<Function> FunctionsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("functions", arguments);
        return await Executor.Execute<Function>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this ObjectTypeDef.
    /// </summary>
    public async Task<ObjectTypeDefID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<ObjectTypeDefID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the object.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The location of this object declaration.
    /// </summary>
    public SourceMap SourceMap()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceMap", arguments);
        return new SourceMap(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// If this ObjectTypeDef is associated with a Module, the name of the module. Unset otherwise.
    /// </summary>
    public async Task<string> SourceModuleNameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceModuleName", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `ObjectTypeDefID` scalar type represents an identifier for an object of type ObjectTypeDef.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<ObjectTypeDefID>))]
public class ObjectTypeDefID : Scalar
{
}

/// <summary>
/// Key value object that represents a pipeline label.
/// </summary>
public struct PipelineLabel(string? name = null, string? value = null) : IInputObject
{
    public Dictionary<string, IFormattedValue> ToDictionary() => this.AsDictionary();
    /// <summary>
    /// Label name.
    /// </summary>
    public string? Name { get; } = name;
    /// <summary>
    /// Label value.
    /// </summary>
    public string? Value { get; } = value;
}

/// <summary>
/// The platform config OS and architecture in a Container.
/// The format is [os]/[platform]/[version] (e.g., "darwin/arm64/v7", "windows/amd64", "linux/arm64").
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<Platform>))]
public class Platform : Scalar
{
}

/// <summary>
/// A port exposed by a container.
/// </summary>
public partial class Port(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<PortID>
{
    /// <summary>
    /// The port description.
    /// </summary>
    public async Task<string> DescriptionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("description", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Skip the health check when run as a service.
    /// </summary>
    public async Task<bool> ExperimentalSkipHealthcheckAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("experimentalSkipHealthcheck", arguments);
        return await Executor.Execute<bool>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this Port.
    /// </summary>
    public async Task<PortID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<PortID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The port number.
    /// </summary>
    public async Task<int> PortAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("port", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The transport layer protocol.
    /// </summary>
    public async Task<NetworkProtocol> ProtocolAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("protocol", arguments);
        return await Executor.Execute<NetworkProtocol>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// Port forwarding rules for tunneling network traffic.
/// </summary>
public struct PortForward(int? frontend = null, int? backend = null, NetworkProtocol? protocol = NetworkProtocol.TCP) : IInputObject
{
    public Dictionary<string, IFormattedValue> ToDictionary() => this.AsDictionary();
    /// <summary>
    /// Port to expose to clients. If unspecified, a default will be chosen.
    /// </summary>
    public int? Frontend { get; } = frontend;
    /// <summary>
    /// Destination port for traffic.
    /// </summary>
    public int? Backend { get; } = backend;
    /// <summary>
    /// Transport layer protocol to use for traffic.
    /// </summary>
    public NetworkProtocol? Protocol { get; } = protocol;
}

/// <summary>
/// The `PortID` scalar type represents an identifier for an object of type Port.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<PortID>))]
public class PortID : Scalar
{
}

/// <summary>
/// The root of the DAG.
/// </summary>
public partial class Query(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient)
{
    /// <summary>
    /// Retrieves a content-addressed blob.
    /// </summary>
    /// <param name="digest">
    /// Digest of the blob
    /// </param>
    public Directory Blob(string digest)
    {
        var arguments = ArgumentsBuilder.GetArguments(digest);
        var queryBuilder = QueryBuilder.Select("blob", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Retrieves a container builtin to the engine.
    /// </summary>
    /// <param name="digest">
    /// Digest of the image manifest
    /// </param>
    public Container BuiltinContainer(string digest)
    {
        var arguments = ArgumentsBuilder.GetArguments(digest);
        var queryBuilder = QueryBuilder.Select("builtinContainer", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Constructs a cache volume for a given cache key.
    /// </summary>
    /// <param name="key">
    /// A string identifier to target this cache volume (e.g., "modules-cache").
    /// </param>
    public CacheVolume CacheVolume(string key)
    {
        var arguments = ArgumentsBuilder.GetArguments(key);
        var queryBuilder = QueryBuilder.Select("cacheVolume", arguments);
        return new CacheVolume(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Creates a scratch container.
    /// Optional platform argument initializes new containers to execute and publish as that platform. Platform defaults to that of the builder's host.
    /// </summary>
    /// <param name="platform">
    /// Platform to initialize the container with.
    /// </param>
    public Container Container(Platform? platform = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(platform);
        var queryBuilder = QueryBuilder.Select("container", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The FunctionCall context that the SDK caller is currently executing in.
    /// If the caller is not currently executing in a function, this will return an error.
    /// </summary>
    public FunctionCall CurrentFunctionCall()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("currentFunctionCall", arguments);
        return new FunctionCall(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The module currently being served in the session, if any.
    /// </summary>
    public CurrentModule CurrentModule()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("currentModule", arguments);
        return new CurrentModule(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The TypeDef representations of the objects currently being served in the session.
    /// </summary>
    public async Task<TypeDef> CurrentTypeDefsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("currentTypeDefs", arguments);
        return await Executor.Execute<TypeDef>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The default platform of the engine.
    /// </summary>
    public async Task<Platform> DefaultPlatformAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("defaultPlatform", arguments);
        return await Executor.Execute<Platform>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Creates an empty directory.
    /// </summary>
    public Directory Directory()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("directory", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// The Dagger engine container configuration and state
    /// </summary>
    public Engine Engine()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("engine", arguments);
        return new Engine(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Create a new error.
    /// </summary>
    /// <param name="message">
    /// A brief description of the error.
    /// </param>
    public Error Error(string message)
    {
        var arguments = ArgumentsBuilder.GetArguments(message);
        var queryBuilder = QueryBuilder.Select("error", arguments);
        return new Error(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Creates a function.
    /// </summary>
    /// <param name="name">
    /// Name of the function, in its original format from the implementation language.
    /// </param>
    /// <param name="returnType">
    /// Return type of the function.
    /// </param>
    public Function Function(string name, TypeDef returnType)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, returnType);
        var queryBuilder = QueryBuilder.Select("function", arguments);
        return new Function(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Create a code generation result, given a directory containing the generated code.
    /// </summary>
    /// <param name="code">
    /// </param>
    public GeneratedCode GeneratedCode(Directory code)
    {
        var arguments = ArgumentsBuilder.GetArguments(code);
        var queryBuilder = QueryBuilder.Select("generatedCode", arguments);
        return new GeneratedCode(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Queries a Git repository.
    /// </summary>
    /// <param name="url">
    /// URL of the git repository.
    /// Can be formatted as `https://{host}/{owner}/{repo}`, `git@{host}:{owner}/{repo}`.
    /// Suffix ".git" is optional.
    /// </param>
    /// <param name="keepGitDir">
    /// DEPRECATED: Set to true to keep .git directory.
    /// </param>
    /// <param name="experimentalServiceHost">
    /// A service which must be started before the repo is fetched.
    /// </param>
    /// <param name="sshKnownHosts">
    /// Set SSH known hosts
    /// </param>
    /// <param name="sshAuthSocket">
    /// Set SSH auth socket
    /// </param>
    public GitRepository Git(string url, bool? keepGitDir = true, Service? experimentalServiceHost = null, string? sshKnownHosts = "", Socket? sshAuthSocket = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(url, keepGitDir, experimentalServiceHost, sshKnownHosts, sshAuthSocket);
        var queryBuilder = QueryBuilder.Select("git", arguments);
        return new GitRepository(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Queries the host environment.
    /// </summary>
    public Host Host()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("host", arguments);
        return new Host(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns a file containing an http remote url content.
    /// </summary>
    /// <param name="url">
    /// HTTP url to get the content from (e.g., "https://docs.dagger.io").
    /// </param>
    /// <param name="experimentalServiceHost">
    /// A service which must be started before the URL is fetched.
    /// </param>
    public File Http(string url, Service? experimentalServiceHost = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(url, experimentalServiceHost);
        var queryBuilder = QueryBuilder.Select("http", arguments);
        return new File(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a CacheVolume from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public CacheVolume LoadCacheVolumeFromID(CacheVolumeID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadCacheVolumeFromID", arguments);
        return new CacheVolume(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Container from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Container LoadContainerFromID(ContainerID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadContainerFromID", arguments);
        return new Container(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a CurrentModule from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public CurrentModule LoadCurrentModuleFromID(CurrentModuleID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadCurrentModuleFromID", arguments);
        return new CurrentModule(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Directory from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Directory LoadDirectoryFromID(DirectoryID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadDirectoryFromID", arguments);
        return new Directory(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a EngineCacheEntry from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public EngineCacheEntry LoadEngineCacheEntryFromID(EngineCacheEntryID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadEngineCacheEntryFromID", arguments);
        return new EngineCacheEntry(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a EngineCacheEntrySet from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public EngineCacheEntrySet LoadEngineCacheEntrySetFromID(EngineCacheEntrySetID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadEngineCacheEntrySetFromID", arguments);
        return new EngineCacheEntrySet(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a EngineCache from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public EngineCache LoadEngineCacheFromID(EngineCacheID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadEngineCacheFromID", arguments);
        return new EngineCache(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Engine from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Engine LoadEngineFromID(EngineID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadEngineFromID", arguments);
        return new Engine(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a EnumTypeDef from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public EnumTypeDef LoadEnumTypeDefFromID(EnumTypeDefID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadEnumTypeDefFromID", arguments);
        return new EnumTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a EnumValueTypeDef from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public EnumValueTypeDef LoadEnumValueTypeDefFromID(EnumValueTypeDefID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadEnumValueTypeDefFromID", arguments);
        return new EnumValueTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a EnvVariable from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public EnvVariable LoadEnvVariableFromID(EnvVariableID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadEnvVariableFromID", arguments);
        return new EnvVariable(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Error from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Error LoadErrorFromID(ErrorID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadErrorFromID", arguments);
        return new Error(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a FieldTypeDef from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public FieldTypeDef LoadFieldTypeDefFromID(FieldTypeDefID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadFieldTypeDefFromID", arguments);
        return new FieldTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a File from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public File LoadFileFromID(FileID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadFileFromID", arguments);
        return new File(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a FunctionArg from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public FunctionArg LoadFunctionArgFromID(FunctionArgID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadFunctionArgFromID", arguments);
        return new FunctionArg(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a FunctionCallArgValue from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public FunctionCallArgValue LoadFunctionCallArgValueFromID(FunctionCallArgValueID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadFunctionCallArgValueFromID", arguments);
        return new FunctionCallArgValue(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a FunctionCall from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public FunctionCall LoadFunctionCallFromID(FunctionCallID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadFunctionCallFromID", arguments);
        return new FunctionCall(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Function from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Function LoadFunctionFromID(FunctionID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadFunctionFromID", arguments);
        return new Function(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a GeneratedCode from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public GeneratedCode LoadGeneratedCodeFromID(GeneratedCodeID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadGeneratedCodeFromID", arguments);
        return new GeneratedCode(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a GitModuleSource from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public GitModuleSource LoadGitModuleSourceFromID(GitModuleSourceID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadGitModuleSourceFromID", arguments);
        return new GitModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a GitRef from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public GitRef LoadGitRefFromID(GitRefID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadGitRefFromID", arguments);
        return new GitRef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a GitRepository from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public GitRepository LoadGitRepositoryFromID(GitRepositoryID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadGitRepositoryFromID", arguments);
        return new GitRepository(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Host from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Host LoadHostFromID(HostID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadHostFromID", arguments);
        return new Host(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a InputTypeDef from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public InputTypeDef LoadInputTypeDefFromID(InputTypeDefID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadInputTypeDefFromID", arguments);
        return new InputTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a InterfaceTypeDef from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public InterfaceTypeDef LoadInterfaceTypeDefFromID(InterfaceTypeDefID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadInterfaceTypeDefFromID", arguments);
        return new InterfaceTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Label from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Label LoadLabelFromID(LabelID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadLabelFromID", arguments);
        return new Label(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a ListTypeDef from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public ListTypeDef LoadListTypeDefFromID(ListTypeDefID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadListTypeDefFromID", arguments);
        return new ListTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a LocalModuleSource from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public LocalModuleSource LoadLocalModuleSourceFromID(LocalModuleSourceID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadLocalModuleSourceFromID", arguments);
        return new LocalModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a ModuleDependency from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public ModuleDependency LoadModuleDependencyFromID(ModuleDependencyID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadModuleDependencyFromID", arguments);
        return new ModuleDependency(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Module from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Module LoadModuleFromID(ModuleID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadModuleFromID", arguments);
        return new Module(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a ModuleSource from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public ModuleSource LoadModuleSourceFromID(ModuleSourceID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadModuleSourceFromID", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a ModuleSourceView from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public ModuleSourceView LoadModuleSourceViewFromID(ModuleSourceViewID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadModuleSourceViewFromID", arguments);
        return new ModuleSourceView(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a ObjectTypeDef from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public ObjectTypeDef LoadObjectTypeDefFromID(ObjectTypeDefID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadObjectTypeDefFromID", arguments);
        return new ObjectTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Port from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Port LoadPortFromID(PortID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadPortFromID", arguments);
        return new Port(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a ScalarTypeDef from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public ScalarTypeDef LoadScalarTypeDefFromID(ScalarTypeDefID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadScalarTypeDefFromID", arguments);
        return new ScalarTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Secret from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Secret LoadSecretFromID(SecretID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadSecretFromID", arguments);
        return new Secret(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Service from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Service LoadServiceFromID(ServiceID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadServiceFromID", arguments);
        return new Service(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Socket from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Socket LoadSocketFromID(SocketID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadSocketFromID", arguments);
        return new Socket(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a SourceMap from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public SourceMap LoadSourceMapFromID(SourceMapID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadSourceMapFromID", arguments);
        return new SourceMap(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a Terminal from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public Terminal LoadTerminalFromID(TerminalID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadTerminalFromID", arguments);
        return new Terminal(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Load a TypeDef from its ID.
    /// </summary>
    /// <param name="id">
    /// </param>
    public TypeDef LoadTypeDefFromID(TypeDefID id)
    {
        var arguments = ArgumentsBuilder.GetArguments(id);
        var queryBuilder = QueryBuilder.Select("loadTypeDefFromID", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Create a new module.
    /// </summary>
    public Module Module()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("module", arguments);
        return new Module(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Create a new module dependency configuration from a module source and name
    /// </summary>
    /// <param name="source">
    /// The source of the dependency
    /// </param>
    /// <param name="name">
    /// If set, the name to use for the dependency. Otherwise, once installed to a parent module, the name of the dependency module will be used by default.
    /// </param>
    public ModuleDependency ModuleDependency(ModuleSource source, string? name = "")
    {
        var arguments = ArgumentsBuilder.GetArguments(source, name);
        var queryBuilder = QueryBuilder.Select("moduleDependency", arguments);
        return new ModuleDependency(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Create a new module source instance from a source ref string.
    /// </summary>
    /// <param name="refString">
    /// The string ref representation of the module source
    /// </param>
    /// <param name="refPin">
    /// The pinned version of the module source
    /// </param>
    /// <param name="stable">
    /// If true, enforce that the source is a stable version for source kinds that support versioning.
    /// </param>
    /// <param name="relHostPath">
    /// The relative path to the module root from the host directory
    /// </param>
    public ModuleSource ModuleSource(string refString, string? refPin = "", bool? stable = false, string? relHostPath = "")
    {
        var arguments = ArgumentsBuilder.GetArguments(refString, refPin, stable, relHostPath);
        var queryBuilder = QueryBuilder.Select("moduleSource", arguments);
        return new ModuleSource(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Reference a secret by name.
    /// </summary>
    /// <param name="name">
    /// </param>
    /// <param name="accessor">
    /// </param>
    public Secret Secret(string name, string? accessor = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, accessor);
        var queryBuilder = QueryBuilder.Select("secret", arguments);
        return new Secret(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Sets a secret given a user defined name to its plaintext and returns the secret.
    /// The plaintext value is limited to a size of 128000 bytes.
    /// </summary>
    /// <param name="name">
    /// The user defined name for this secret
    /// </param>
    /// <param name="plaintext">
    /// The plaintext of the secret
    /// </param>
    public Secret SetSecret(string name, string plaintext)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, plaintext);
        var queryBuilder = QueryBuilder.Select("setSecret", arguments);
        return new Secret(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Creates source map metadata.
    /// </summary>
    /// <param name="filename">
    /// The filename from the module source.
    /// </param>
    /// <param name="line">
    /// The line number within the filename.
    /// </param>
    /// <param name="column">
    /// The column number within the line.
    /// </param>
    public SourceMap SourceMap(string filename, int line, int column)
    {
        var arguments = ArgumentsBuilder.GetArguments(filename, line, column);
        var queryBuilder = QueryBuilder.Select("sourceMap", arguments);
        return new SourceMap(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Create a new TypeDef.
    /// </summary>
    public TypeDef TypeDef()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("typeDef", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Get the current Dagger Engine version.
    /// </summary>
    public async Task<string> VersionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("version", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// Expected return type of an execution
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter<ReturnType>))]
public enum ReturnType
{
    /// <summary>
    /// A successful execution (exit code 0)
    /// </summary>
    SUCCESS,
    /// <summary>
    /// A failed execution (exit codes 1-127)
    /// </summary>
    FAILURE,
    /// <summary>
    /// Any execution (exit codes 0-127)
    /// </summary>
    ANY
}

/// <summary>
/// A definition of a custom scalar defined in a Module.
/// </summary>
public partial class ScalarTypeDef(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<ScalarTypeDefID>
{
    /// <summary>
    /// A doc string for the scalar, if any.
    /// </summary>
    public async Task<string> DescriptionAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("description", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this ScalarTypeDef.
    /// </summary>
    public async Task<ScalarTypeDefID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<ScalarTypeDefID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of the scalar.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// If this ScalarTypeDef is associated with a Module, the name of the module. Unset otherwise.
    /// </summary>
    public async Task<string> SourceModuleNameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sourceModuleName", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `ScalarTypeDefID` scalar type represents an identifier for an object of type ScalarTypeDef.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<ScalarTypeDefID>))]
public class ScalarTypeDefID : Scalar
{
}

/// <summary>
/// A reference to a secret value, which can be handled more safely than the value itself.
/// </summary>
public partial class Secret(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<SecretID>
{
    /// <summary>
    /// A unique identifier for this Secret.
    /// </summary>
    public async Task<SecretID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<SecretID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The name of this secret.
    /// </summary>
    public async Task<string> NameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("name", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The value of this secret.
    /// </summary>
    public async Task<string> PlaintextAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("plaintext", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `SecretID` scalar type represents an identifier for an object of type Secret.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<SecretID>))]
public class SecretID : Scalar
{
}

/// <summary>
/// A content-addressed service providing TCP connectivity.
/// </summary>
public partial class Service(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<ServiceID>
{
    /// <summary>
    /// Retrieves an endpoint that clients can use to reach this container.
    /// If no port is specified, the first exposed port is used. If none exist an error is returned.
    /// If a scheme is specified, a URL is returned. Otherwise, a host:port pair is returned.
    /// </summary>
    /// <param name="port">
    /// The exposed port number for the endpoint
    /// </param>
    /// <param name="scheme">
    /// Return a URL with the given scheme, eg. http for http://
    /// </param>
    public async Task<string> EndpointAsync(int? port = null, string? scheme = "")
    {
        var arguments = ArgumentsBuilder.GetArguments(port, scheme);
        var queryBuilder = QueryBuilder.Select("endpoint", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves a hostname which can be used by clients to reach this container.
    /// </summary>
    public async Task<string> HostnameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("hostname", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this Service.
    /// </summary>
    public async Task<ServiceID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<ServiceID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Retrieves the list of ports provided by the service.
    /// </summary>
    public async Task<Port> PortsAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("ports", arguments);
        return await Executor.Execute<Port>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Start the service and wait for its health checks to succeed.
    /// Services bound to a Container do not need to be manually started.
    /// </summary>
    public async Task<ServiceID> StartAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("start", arguments);
        return await Executor.Execute<ServiceID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Stop the service.
    /// </summary>
    /// <param name="kill">
    /// Immediately kill the service without waiting for a graceful exit
    /// </param>
    public async Task<ServiceID> StopAsync(bool? kill = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(kill);
        var queryBuilder = QueryBuilder.Select("stop", arguments);
        return await Executor.Execute<ServiceID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Creates a tunnel that forwards traffic from the caller's network to this service.
    /// </summary>
    /// <param name="ports">
    /// List of frontend/backend port mappings to forward.
    /// Frontend is the port accepting traffic on the host, backend is the service port.
    /// </param>
    /// <param name="random">
    /// Bind each tunnel port to a random port on the host.
    /// </param>
    public async Task<Void> UpAsync(PortForward[]? ports = null, bool? random = false)
    {
        var arguments = ArgumentsBuilder.GetArguments(ports, random);
        var queryBuilder = QueryBuilder.Select("up", arguments);
        return await Executor.Execute<Void>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Configures a hostname which can be used by clients within the session to reach this container.
    /// </summary>
    /// <param name="hostname">
    /// The hostname to use.
    /// </param>
    public Service WithHostname(string hostname)
    {
        var arguments = ArgumentsBuilder.GetArguments(hostname);
        var queryBuilder = QueryBuilder.Select("withHostname", arguments);
        return new Service(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `ServiceID` scalar type represents an identifier for an object of type Service.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<ServiceID>))]
public class ServiceID : Scalar
{
}

/// <summary>
/// A Unix or TCP/IP socket that can be mounted into a container.
/// </summary>
public partial class Socket(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<SocketID>
{
    /// <summary>
    /// A unique identifier for this Socket.
    /// </summary>
    public async Task<SocketID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<SocketID>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `SocketID` scalar type represents an identifier for an object of type Socket.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<SocketID>))]
public class SocketID : Scalar
{
}

/// <summary>
/// Source location information.
/// </summary>
public partial class SourceMap(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<SourceMapID>
{
    /// <summary>
    /// The column number within the line.
    /// </summary>
    public async Task<int> ColumnAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("column", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The filename from the module source.
    /// </summary>
    public async Task<string> FilenameAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("filename", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// A unique identifier for this SourceMap.
    /// </summary>
    public async Task<SourceMapID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<SourceMapID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The line number within the filename.
    /// </summary>
    public async Task<int> LineAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("line", arguments);
        return await Executor.Execute<int>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The module dependency this was declared in.
    /// </summary>
    public async Task<string> ModuleAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("module", arguments);
        return await Executor.Execute<string>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `SourceMapID` scalar type represents an identifier for an object of type SourceMap.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<SourceMapID>))]
public class SourceMapID : Scalar
{
}

/// <summary>
/// The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<String>))]
public class String : Scalar
{
}

/// <summary>
/// An interactive terminal that clients can connect to.
/// </summary>
public partial class Terminal(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<TerminalID>
{
    /// <summary>
    /// A unique identifier for this Terminal.
    /// </summary>
    public async Task<TerminalID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<TerminalID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Forces evaluation of the pipeline in the engine.
    /// It doesn't run the default command if no exec has been set.
    /// </summary>
    public async Task<TerminalID> SyncAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("sync", arguments);
        return await Executor.Execute<TerminalID>(GraphQLClient, queryBuilder);
    }
}

/// <summary>
/// The `TerminalID` scalar type represents an identifier for an object of type Terminal.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<TerminalID>))]
public class TerminalID : Scalar
{
}

/// <summary>
/// A definition of a parameter or return type in a Module.
/// </summary>
public partial class TypeDef(QueryBuilder QueryBuilder, GraphQLClient GraphQLClient) : IId<TypeDefID>
{
    /// <summary>
    /// If kind is ENUM, the enum-specific type definition. If kind is not ENUM, this will be null.
    /// </summary>
    public EnumTypeDef AsEnum()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("asEnum", arguments);
        return new EnumTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// If kind is INPUT, the input-specific type definition. If kind is not INPUT, this will be null.
    /// </summary>
    public InputTypeDef AsInput()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("asInput", arguments);
        return new InputTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// If kind is INTERFACE, the interface-specific type definition. If kind is not INTERFACE, this will be null.
    /// </summary>
    public InterfaceTypeDef AsInterface()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("asInterface", arguments);
        return new InterfaceTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// If kind is LIST, the list-specific type definition. If kind is not LIST, this will be null.
    /// </summary>
    public ListTypeDef AsList()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("asList", arguments);
        return new ListTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// If kind is OBJECT, the object-specific type definition. If kind is not OBJECT, this will be null.
    /// </summary>
    public ObjectTypeDef AsObject()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("asObject", arguments);
        return new ObjectTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// If kind is SCALAR, the scalar-specific type definition. If kind is not SCALAR, this will be null.
    /// </summary>
    public ScalarTypeDef AsScalar()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("asScalar", arguments);
        return new ScalarTypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// A unique identifier for this TypeDef.
    /// </summary>
    public async Task<TypeDefID> IdAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("id", arguments);
        return await Executor.Execute<TypeDefID>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// The kind of type this is (e.g. primitive, list, object).
    /// </summary>
    public async Task<TypeDefKind> KindAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("kind", arguments);
        return await Executor.Execute<TypeDefKind>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Whether this type can be set to null. Defaults to false.
    /// </summary>
    public async Task<bool> OptionalAsync()
    {
        var arguments = ArgumentsBuilder.GetArguments();
        var queryBuilder = QueryBuilder.Select("optional", arguments);
        return await Executor.Execute<bool>(GraphQLClient, queryBuilder);
    }

    /// <summary>
    /// Adds a function for constructing a new instance of an Object TypeDef, failing if the type is not an object.
    /// </summary>
    /// <param name="function">
    /// </param>
    public TypeDef WithConstructor(Function function)
    {
        var arguments = ArgumentsBuilder.GetArguments(function);
        var queryBuilder = QueryBuilder.Select("withConstructor", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns a TypeDef of kind Enum with the provided name.
    /// Note that an enum's values may be omitted if the intent is only to refer to an enum. This is how functions are able to return their own, or any other circular reference.
    /// </summary>
    /// <param name="name">
    /// The name of the enum
    /// </param>
    /// <param name="description">
    /// A doc string for the enum, if any
    /// </param>
    /// <param name="sourceMap">
    /// The source map for the enum definition.
    /// </param>
    public TypeDef WithEnum(string name, string? description = "", SourceMap? sourceMap = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, description, sourceMap);
        var queryBuilder = QueryBuilder.Select("withEnum", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Adds a static value for an Enum TypeDef, failing if the type is not an enum.
    /// </summary>
    /// <param name="value">
    /// The name of the value in the enum
    /// </param>
    /// <param name="description">
    /// A doc string for the value, if any
    /// </param>
    /// <param name="sourceMap">
    /// The source map for the enum value definition.
    /// </param>
    public TypeDef WithEnumValue(string value, string? description = "", SourceMap? sourceMap = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(value, description, sourceMap);
        var queryBuilder = QueryBuilder.Select("withEnumValue", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Adds a static field for an Object TypeDef, failing if the type is not an object.
    /// </summary>
    /// <param name="name">
    /// The name of the field in the object
    /// </param>
    /// <param name="typeDef">
    /// The type of the field
    /// </param>
    /// <param name="description">
    /// A doc string for the field, if any
    /// </param>
    /// <param name="sourceMap">
    /// The source map for the field definition.
    /// </param>
    public TypeDef WithField(string name, TypeDef typeDef, string? description = "", SourceMap? sourceMap = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, typeDef, description, sourceMap);
        var queryBuilder = QueryBuilder.Select("withField", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Adds a function for an Object or Interface TypeDef, failing if the type is not one of those kinds.
    /// </summary>
    /// <param name="function">
    /// </param>
    public TypeDef WithFunction(Function function)
    {
        var arguments = ArgumentsBuilder.GetArguments(function);
        var queryBuilder = QueryBuilder.Select("withFunction", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns a TypeDef of kind Interface with the provided name.
    /// </summary>
    /// <param name="name">
    /// </param>
    /// <param name="description">
    /// </param>
    /// <param name="sourceMap">
    /// </param>
    public TypeDef WithInterface(string name, string? description = "", SourceMap? sourceMap = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, description, sourceMap);
        var queryBuilder = QueryBuilder.Select("withInterface", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Sets the kind of the type.
    /// </summary>
    /// <param name="kind">
    /// </param>
    public TypeDef WithKind(TypeDefKind kind)
    {
        var arguments = ArgumentsBuilder.GetArguments(kind);
        var queryBuilder = QueryBuilder.Select("withKind", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns a TypeDef of kind List with the provided type for its elements.
    /// </summary>
    /// <param name="elementType">
    /// </param>
    public TypeDef WithListOf(TypeDef elementType)
    {
        var arguments = ArgumentsBuilder.GetArguments(elementType);
        var queryBuilder = QueryBuilder.Select("withListOf", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns a TypeDef of kind Object with the provided name.
    /// Note that an object's fields and functions may be omitted if the intent is only to refer to an object. This is how functions are able to return their own object, or any other circular reference.
    /// </summary>
    /// <param name="name">
    /// </param>
    /// <param name="description">
    /// </param>
    /// <param name="sourceMap">
    /// </param>
    public TypeDef WithObject(string name, string? description = "", SourceMap? sourceMap = null)
    {
        var arguments = ArgumentsBuilder.GetArguments(name, description, sourceMap);
        var queryBuilder = QueryBuilder.Select("withObject", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Sets whether this type can be set to null.
    /// </summary>
    /// <param name="optional">
    /// </param>
    public TypeDef WithOptional(bool optional)
    {
        var arguments = ArgumentsBuilder.GetArguments(optional);
        var queryBuilder = QueryBuilder.Select("withOptional", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }

    /// <summary>
    /// Returns a TypeDef of kind Scalar with the provided name.
    /// </summary>
    /// <param name="name">
    /// </param>
    /// <param name="description">
    /// </param>
    public TypeDef WithScalar(string name, string? description = "")
    {
        var arguments = ArgumentsBuilder.GetArguments(name, description);
        var queryBuilder = QueryBuilder.Select("withScalar", arguments);
        return new TypeDef(queryBuilder, GraphQLClient);
    }
}

/// <summary>
/// The `TypeDefID` scalar type represents an identifier for an object of type TypeDef.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<TypeDefID>))]
public class TypeDefID : Scalar
{
}

/// <summary>
/// Distinguishes the different kinds of TypeDefs.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter<TypeDefKind>))]
public enum TypeDefKind
{
    /// <summary>
    /// A string value.
    /// </summary>
    STRING_KIND,
    /// <summary>
    /// An integer value.
    /// </summary>
    INTEGER_KIND,
    /// <summary>
    /// A boolean value.
    /// </summary>
    BOOLEAN_KIND,
    /// <summary>
    /// A scalar value of any basic kind.
    /// </summary>
    SCALAR_KIND,
    /// <summary>
    /// A list of values all having the same type.
    /// Always paired with a ListTypeDef.
    /// </summary>
    LIST_KIND,
    /// <summary>
    /// A named type defined in the GraphQL schema, with fields and functions.
    /// Always paired with an ObjectTypeDef.
    /// </summary>
    OBJECT_KIND,
    /// <summary>
    /// A named type of functions that can be matched+implemented by other objects+interfaces.
    /// Always paired with an InterfaceTypeDef.
    /// </summary>
    INTERFACE_KIND,
    /// <summary>
    /// A graphql input type, used only when representing the core API via TypeDefs.
    /// </summary>
    INPUT_KIND,
    /// <summary>
    /// A special kind used to signify that no value is returned.
    /// This is used for functions that have no return value. The outer TypeDef specifying this Kind is always Optional, as the Void is never actually represented.
    /// </summary>
    VOID_KIND,
    /// <summary>
    /// A GraphQL enum type and its values
    /// Always paired with an EnumTypeDef.
    /// </summary>
    ENUM_KIND
}

/// <summary>
/// The absence of a value.
/// A Null Void is used as a placeholder for resolvers that do not return anything.
/// </summary>
[JsonConverter(typeof(ScalarIdConverter<Void>))]
public class Void : Scalar
{
}